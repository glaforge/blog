<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cédric Champeau's blog: About the author</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">    

    <!-- Le styles -->
    <link href="/blog/css/bootstrap.min.css" rel="stylesheet">
    <link href="/blog/css/asciidoctor.css" rel="stylesheet">
    <link href="/blog/css/base.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="favicon.ico">
    </head>
  <body>
    <div id="wrap">
	
	<!-- Fixed navbar -->
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
          <div class="container">
	    <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">Cédric Champeau's blog</a>
	    </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">                
                <li><a href="/blog/about.html">About</a></li>
		<li><a href="/blog/conferences.html">Conferences</a></li>
                <li><a href="/blog/feed.xml">Feed</a></li>                
              </ul>
            </div>
          </div>
      </div>
      <div class="container">

	<div class="page-header">
		<h1>Blog TEST</h1>
		<h2>Next conferences</h2>
		<div class="lanyrd-target-splat"><a href="http://lanyrd.com/profile/cedricchampeau/" class="lanyrd-splat lanyrd-number-3 lanyrd-context-future" rel="me">My conferences on Lanyrd</a></div>
	</div>
  			<a href="/blog/2014/01/closure_param_inference.html"><h1>Closure parameter type inference for Groovy</h1></a>
  			<p>07 janvier 2014</p>
			<p><em>Tags: </em>groovy </em> closure </em> type checking </em> inference </p>
			<a href="https://twitter.com/share" class="twitter-share-button" data-text="Closure parameter type inference for Groovy" data-url="http://melix.github.io/blog/2014/01/closure_param_inference.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
			<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2014/01/closure_param_inference.html"></div>

  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start 2014 with a new blog post about a long standing request since we introduced static type checking in Groovy 2: closure parameter type inference.
Before we start, let me wish you a happy new year and a lot of open source contributions!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_checking_closure_parameter_types">Type checking closure parameter types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To illustrate the problem, let&#8217;s start with this very simple, standard, Groovy code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>void test() {
    assert ['foo','bar','baz'].collect { it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code compiles and runs perfectly fine. Now if you want the <em>test</em> method to be type safe, you can annotate it with <em>@TypeChecked</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert ['foo','bar','baz'].collect { it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you compile this, you will notice that the compiler fails with an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 5, column: 42</pre>
</div>
</div>
<div class="paragraph">
<p>Fixing this requires an explicit closure parameter type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert ['foo','bar','baz'].collect { String it -&gt; it.toUpperCase() } == ['FOO','BAR','BAZ']
}
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem comes from the <em>collect</em> method, which accepts a <code>Closure</code>. In Groovy, a <code>Closure</code> is a block of code which may capture variables, but it is also
represented as an object of the class <code>Closure</code>. This is a different concept from Java 8 lambdas, which have no <em>Lambda</em> class, for example. A Java 8 lambda can
be considered as purely syntactic sugar, which is interpreted as an interface implementation at compile time, although a <code>Closure</code> can be manipulated. To illustrate
this, let&#8217;s compare the signatures of <em>collect</em> (in Groovy) and <code>Map</code> (in Java 8) which correspond to the same concept:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>items of the source list are of type T and converted to type U using the closure</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); <b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Function is an interface, the lambda expression will be converted into this target interface</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Java 8 equivalent would therefore be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>list.stream().map((it)-&gt;it.toUpperCase()).collect(Collectors.toList()); <b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>we&#8217;re not using the smarter method reference notation here, to illustrate the concept</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, Java allows the same thing as Groovy but doesn&#8217;t require an explicit type. The reason is that for Java, there&#8217;s no ambiguity:
it makes use of <em>target typing</em>. Since a lambda is targetting an interface, the type of the parameters can be inferred from the interface type.
In Groovy, we can&#8217;t do this, because <code>Closure</code> is not an interface. It is a class which can be manipulated. At this point, you may wonder why
we don&#8217;t do the same as in Java, and there are several reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>historical reason first, <code>Closure</code> was one of the key features of the language, 10 years ago!</p>
</li>
<li>
<p>a single class, <code>Closure</code>, is enough for <strong>all</strong> usages of an open block. We don&#8217;t need Function, Consumer, BiFunction, &#8230; So we can dramatically
reduce the amount of "design interfaces"</p>
</li>
<li>
<p>last but not least, <em>Closures</em> support various delegation strategies. This is something Java (or even Scala) is totally unable to do. <code>Closure</code> can
be <em>cloned</em>, <em>curried</em>, <em>trampolined</em>, &#8230; and it always returns an instance of another <code>Closure</code>. This closure can change the delegate, which is the
key for nice builder like DSLs. The delegate is used whenever a method call in a closure doesn&#8217;t have an explicit receiver. For example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>mail {
   from 'austin.powers@groovy.baby'
   to 'mini.me@evil.com'
   subject 'Attention please!'
   body '...'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this DSL, the <em>from</em>, <em>to</em>, <em>subject</em> and <em>body</em> method calls are done on the <em>delegate</em>. Being able to set the <em>delegate</em> absolutely requires a
<code>Closure</code> class. The implementation of the mail method may have something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>class EmailSpecification {
    void from(String sender) { ... }
    void to(String to) { ... }
    void subject(String subject) { ... }
    void body(String body) { ... }
    void mail(Closure mail) {
       def mailSpec = mail.clone()
       mailSpec.delegate = this
       mailSpec()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem with this approach is that if the closure requires parameters, like in the <em>collect</em> case, the Java type system, as well as the Groovy type
system (which is the same), isn&#8217;t expressive enough to let you define them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We could like to say that Closure returns a U, but also that it consumes a T</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Of course the first option that was studied was defining lots of <code>Closure</code> interfaces, corresponding to the various number of arguments (up to some arbitrary limit):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure1&lt;T,U&gt; closure) <b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Closure1 is a kind of closure which accepts a single argument and returns a value</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While this works, it has several drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it requires a lot of arbitrary, totally useless in a dynamic context, number of interfaces/classes to define closures</p>
</li>
<li>
<p>it doesn&#8217;t solve the case of polymorphic closures</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_polymorphic_closures">Polymorphic closures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Polywhat? In Groovy, closures can be polymorphic. To illustrate the concept, let&#8217;s take a look at a common method that iterates on map entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def map = [key1: 'value 1', key2: 'value2']
map.each { k,v -&gt; println "Key is $k, value is $v" } <b>(1)</b>
map.each { e -&gt; println "Key is ${e.key], value is ${e.value}" } <b>(2)</b>
map.each { println "Key is ${it.key], value is ${it.value}" } <b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>version where the map entry is automatically converted into a key and value arguments</p>
</li>
<li>
<p>version where the closure takes a single, <code>Map.Entry</code> argument</p>
</li>
<li>
<p>version with an implicit argument, it, is a <code>Map.Entry</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In all cases, it is always the <strong>same</strong> method which is called, that is to say <em>each(Closure)</em> on a <code>Map</code>. The signature of this method is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;K,V&gt; each(Map&lt;K,V&gt; self, Closure&lt;?&gt; onEachEntry)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, the return type of the closure doesn&#8217;t help here, and just reading that signature, you have absolutely no way to guess that the closure
will accept either a <code>Map.Entry</code> or a pair of <code>K,V</code>. Nor does the compiler. At best, your IDE knows it, and it does because it is hardcoded! This is
exactly why the compiler fails, and also why so many people think it&#8217;s <a href="https://jira.codehaus.org/browse/GROOVY-5924">a bug</a>.</p>
</div>
<div class="paragraph">
<p>Not convinced? Let&#8217;s make the same signature more cryptic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;Dead,Pool&gt; magneto(Map&lt;Dead,Pool&gt; self, Closure&lt;?&gt; professorX)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now can you guess what <em>professorX</em> accepts as parameters? ;)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tweaking_the_type_system">Tweaking the type system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have discussed several options and we took the time to think about it, and after the last Groovy DevCon, which took place just before the
<a href="http://skillsmatter.com/event-details/home/groovy-grails-exchange-2013">Groovy and Grails eXchange 2013</a> in London, I decided to work on an implementation.
For Groovy 2.1, we had introduced <em>@DelegatesTo</em> for closures, to be able to help the compiler in the case we described above (hinting at the delegate type)
but we were still missing parameter type inference. My guess was that it was possible to do something similar to what <em>@DelegatesTo</em> does, but for parameter
types.</p>
</div>
<div class="sect2">
<h3 id="_annotating_closures">Annotating closures</h3>
<div class="paragraph">
<p>The idea is to annotate closures so that the compiler can fetch the information and infer the argument types from the context. In the case of a simple method
accepting a closure, a simple annotation could do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>void doSomething(String src, @ClosureParams(String.class) Closure cl) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>@ClosureParams</em> annotation is here to instruct the compiler that the closure will accept either an <em>implicit</em> or <em>explicit</em> parameter of type <em>String</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>doSomething {
   it.toUpperCase()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the compiler determines that the method which will be called is <em>doSomething</em> (remember that this is only possible if type checking is activated), then an
additional lookup on the <em>doSomething</em> signature can be done, and we can retrieve the list of expected parameter types from the closure annotation. Success!</p>
</div>
<div class="paragraph">
<p>Well, not really:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>we still don&#8217;t support polymorphic closures</p>
</li>
<li>
<p>generics, GENERICS, aaahhhh, GENERICS!</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_introducing_generics">Introducing&#8230; generics!</h3>
<div class="paragraph">
<p>To make things a bit more complicated, we have generics. Don&#8217;t get me wrong. From a user perspective, generics are very good because they make the code more readable
and help reduce the amount of boilerplate (think of vectors/maps before Java 1.5&#8230;). The typical case is the <em>collect</em> example that we used initially:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, Closure&lt;U&gt; closure) <b>(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, we want to say that the closure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is monomorphic</p>
</li>
<li>
<p>accepts a single parameter of type T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and the problem is&#8230; how to express this? One might think that you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T,U&gt; List&lt;U&gt; collect(List&lt;T&gt; source, @ClosureParams(T) Closure&lt;U&gt; closure) <b>(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>but the truth is that the JVM doesn&#8217;t support placeholders as annotation values, nor does it support parametrized types (like <code>@Foo(List&lt;T&gt;</code>)). This tells us that the simple strategy doesn&#8217;t work.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_solution">The solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The solution we propose is to decouple the declaration of the parameter types from the type itself. In other words, instead of declaring the types in the annotation, we will declare an object
which is used as a hint to compute the types <strong>at compile time</strong>. In the case of <em>collect</em>, we end up with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static &lt;T,E&gt; List&lt;T&gt; collect(List&lt;E&gt; self, @ClosureParams(FirstParam.FirstGenericType.class) Closure&lt;? extends T&gt; transform)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>FirstParam.FirstGenericType</code> doesn&#8217;t represent the type itself. It&#8217;s a hint used by the compiler, which says "the type of the argument is the type of the first generic type of the first parameter". In this case, the first parameter is <code>List&lt;E&gt;</code>, so the first generic type is <code>E</code>. This means that if you call the method with a <code>List&lt;String&gt;</code>, now the compiler can infer that <code>E</code> is a <code>String</code>.</p>
</div>
<div class="sect2">
<h3 id="_type_hints">Type hints</h3>
<div class="paragraph">
<p>At this point, you may actually think that this "solution" is a bit complex. However, you have to remember that this kind of work is only necessary if you want to support type inference, so it is really only necessary if you use type checking. This makes this a tool primarily aimed at framework builders. In particular, lots of frameworks are written in Java (including Groovy itself), so the syntax <strong>has</strong> to be compatible with Java. Second, there&#8217;s no need to define one <code>FirstParam.FirstGenericType</code> class per method. The same class can be reused for all cases where it makes sense. Remember that it doesn&#8217;t represent the type of the parameters but a way to fetch the type (one level of indirection).</p>
</div>
<div class="paragraph">
<p>To make things easier for framework writers, the <a href="https://github.com/groovy/groovy-core/pull/307">candidate implementation</a> provides a set of predefined hint classes that should fit most of
the use cases. Let&#8217;s go through the list:</p>
</div>
<div class="sect3">
<h4 id="_firstparam">FirstParam</h4>
<div class="paragraph">
<p><code>FirstParam</code> is a hint that says that the expected parameter type corresponds to the first parameter of the method call, like in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static void downto(BigInteger self, Number to, @ClosureParams(FirstParam.class) Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The closure accepts a single parameter of type <code>BigInteger</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_firstparam_firstgenerictype">FirstParam.FirstGenericType</h4>
<div class="paragraph">
<p>This hint is used when the type to use is not the type of the parameter, but the type of the first generic type of the first argument, like in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static &lt;T,E&gt; Collection&lt;T&gt; collect(Collection&lt;E&gt; self, Collection&lt;T&gt; collector, @ClosureParams(FirstParam.FirstGenericType.class) Closure&lt;? extends T&gt; transform)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you have a <code>Collection</code> defined like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>class PersonList extends LinkedList&lt;Person&gt; {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and that you call collect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>list.collect { it.name }</code></pre>
</div>
</div>
<div class="paragraph">
<p>the compiler will be capable of inferring that the type of the first generic type is actually a <code>Person</code>.</p>
</div>
<div class="paragraph">
<p><code>FirstParam</code> also supports <code>SecondGenericType</code> and <code>ThirdGenericType</code>. You can also find <code>SecondParam</code> and <code>ThirdParam</code> which follow the same structure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapentryorkeyvalue">MapEntryOrKeyValue</h4>
<div class="paragraph">
<p>This hint is used for cases where the closure may accept a <code>Map.Entry</code> or a <em>key,value</em> pair, which is quite common in the Groovy GDK, like <em>each</em> on maps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static &lt;K, V&gt; Map&lt;K, V&gt; each(Map&lt;K, V&gt; self, @ClosureParams(MapEntryOrKeyValue.class) Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is an example of polymorphic closure. This hint does all the job of telling that the parameter types may be a <code>K,V</code> pair or a <code>Map.Entry&lt;K,V&gt;</code>. For that, it expects the map to be the first parameter of the method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_simpletype">SimpleType</h4>
<div class="paragraph">
<p>Simple type can be used for monomorphic closures, in the cases the closure accepts parameters of a non-parametrized type. In this case, you need to use an option to specify the fully qualified name, like in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static void eachByte(InputStream is, @ClosureParams(value=SimpleType.class, options="byte") Closure closure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the closure accepts a single parameter of type <code>byte</code>. For a non primitive type, you need the fully qualified name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static Writable filterLine(InputStream self, @ClosureParams(value=SimpleType.class, options="java.lang.String") Closure predicate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the closure accepts multiple arguments then you need options to be an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static &lt;T&gt; T withObjectStreams(Socket socket, @ClosureParams(value=SimpleType.class, options={"java.io.ObjectInputStream","java.io.ObjectOutputStream"}) Closure&lt;T&gt; closure)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fromstring">FromString</h4>
<div class="paragraph">
<p>The last predefined hint can be used whenever none of the previous hints is suitable. A good example is the <em>sort</em> method on a collection, which takes a closure which either accepts a single
parameter of type <code>T</code> (where <code>T</code> is the component type) or two parameters of type <code>T</code> in which case we have a comparator-style closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>public static &lt;T&gt; List&lt;T&gt; sort(Collection&lt;T&gt; self, @ClosureParams(value=FromString.class, options={"T","T,T"} Closure c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, in this example, the <em>options</em> map defines two possible signatures. The string literal are used at compile time to match those of the method signature. Since it involves much more work for the compiler, it is not recommanded to use <code>FromString</code> if other options are available, because it would be slower at compile time.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_future_work">Future work</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The candidate implementation is available on <a href="https://github.com/groovy/groovy-core/pull/307">GitHub</a>. It works pretty well, and honestly, I couldn&#8217;t come with any better idea. One very good point of this implementation is that it is Java friendly. You can annotate classes written in pure Java and the Groovy compiler would be able to use the extra information. In the future, we could probably support a nicer syntax for Groovy, but it would require a grammar change, which is not planned until Groovy 3. For example, we could write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>public static &lt;T&gt; List&lt;T&gt; sort(Collection&lt;T&gt; self, Closure&lt;T or T,T -&gt; ?&gt; c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which would totally avoid the "ugliness" of the annotation, while using the same backing tool.</p>
</div>
<div class="paragraph">
<p>Last thing, do not hesitate to comment on this blog about the solution we found. Of course, it took some time, and the discussions can be found here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://groovy.329449.n5.nabble.com/TypeChecked-type-inference-does-not-work-with-closure-td5709972.html#a5709981">an example of user complaint</a></p>
</li>
<li>
<p><a href="http://groovy.329449.n5.nabble.com/Closure-parameter-types-inference-td4978037.html">Initial, not satisfying, solution, two years ago</a></p>
</li>
<li>
<p><a href="http://groovy.329449.n5.nabble.com/Closure-parameter-type-inference-td5717804.html">discussion about this solution</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thanks to everybody who participated in the discussion, and, of course, thank you for your comments if any: this is still a <em>candidate</em> solution, so if you come with any better idea, I&#8217;m open!</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2014/01/closure_param_inference.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2013/11/22/coercion_vs_direct.html"><h1>Performance of coercion vs closures in Groovy 2.2</h1></a>
  			<p>22 novembre 2013</p>
			<p><em>Tags: </em>groovy </em> coercion </em> performance </em> gbench </p>
			<a href="https://twitter.com/share" class="twitter-share-button" data-text="Performance of coercion vs closures in Groovy 2.2" data-url="http://melix.github.io/blog/2013/11/22/coercion_vs_direct.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
			<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2013/11/22/coercion_vs_direct.html"></div>

  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>To inaugurate this new blog, I will discuss the topic of coercion performance in Groovy. Especially, you might now
that Groovy 2.2 <a href="http://docs.codehaus.org/display/GROOVY/Groovy+2.2+release+notes">introduced implicit closure coercion</a>.
If you don&#8217;t know what closure coercion is, or just what <em>coercion</em> alone is, let&#8217;s start with a reminder.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_casting_vs_coercion">Casting vs coercion</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_casting">Casting</h3>
<div class="paragraph">
<p>In an object oriented language like <a href="http://groovy.codehaus.org">Groovy</a>, variables are typed. Even if Groovy is a dynamic
language, each variable has a type at runtime. Even if Groovy shares the same typing model as Java, there&#8217;s almost no
need for casting in Groovy.</p>
</div>
<div class="paragraph">
<p>Casting in Java is necessary because it&#8217;s a statically typed language, so if you want to call a method defined on the
<code>Person</code> class on an object which is declared as type <code>Object</code>, you <strong>have</strong> to do a cast:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint java language-java"><code>String pretty(Object o) {
    if (o instanceof Person) {
	return ((Person)o).getName(); <b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>(Person) is an explicit cast</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>in Groovy, casting is not necessary because we rely on runtime types and dynamic invocation. This means that this code is
equivalent to this in Groovy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>String pretty(o) {
    o.name <b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>casting isn&#8217;t required</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Casting is only possible within the type hierarchy. That is, you can cast any object to any subtype (or interface) and it&#8217;s
you&#8217;re responsability to make sure (for example using <code>instanceof</code>) that the runtime type will be correct. If you don&#8217;t, you
may have the famous <code>ClassCastException</code> error at runtime.</p>
</div>
</div>
<div class="sect2">
<h3 id="_coercion">Coercion</h3>
<div class="paragraph">
<p>For types which are not in the same hierarchy, Groovy provides an alternative mechanism called <em>coercion</em>. Coercion is very
handy because it basically allows you to convert an object of some type into an object of another, in general incompatible, type.</p>
</div>
<div class="paragraph">
<p>A good example is converting a <code>File</code> to a <code>String[]</code> corresponding to the lines of a text file. In groovy, you can write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def lines = file as String[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, if you had written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def lines = (String[]) file</code></pre>
</div>
</div>
<div class="paragraph">
<p>then it would have produced a <code>ClassCastException</code>. Basically, a cast is (almost) a no-op, while coercion involves any kind of
treatment. It is also possible to implement your own coercion rules, by implementing the <code>asType</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>class Person {
   String name
   int age
   def asType(Class target) {
      if (List==target) {
         [name,age]
      }
   }
}
def p = new Person(name:'Austin Powers', age:50)
assert p as List == ['Austin Powers', 50]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_closure_coercion">Closure coercion</h3>
<div class="paragraph">
<p>One of the most widely used features of Groovy is closure coercion. It&#8217;s an easy way to implement interfaces. For example, giving
the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>interface Predicate {
    boolean apply(Object target)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can implement it using coercion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>Predicate filter = { it.length() &gt; 3 } as Predicate</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is especially interesting when the interface is used as a method call parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>List filter(List source, Predicate predicate) {
   source.findAll { predicate.apply(it) } <b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>note that this example doesn&#8217;t really make sense since it&#8217;s the role of findAll to apply a closure as predicate!</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>So you can call the method without having to create an anonymous abstract class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def items = filter(['foo','bar', 'foobar'], {
    it.length()&gt;3
} as Predicate)
assert items == ['foobar']</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implicit_closure_coercion_in_groovy_2_2">Implicit closure coercion in Groovy 2.2</h3>
<div class="paragraph">
<p>With the release of Groovy 2.2, closure coercion can be implicit, in case the target is a SAM (single abstract method) type. That is to say that the target type must have a single abstract method, which is the case for many functional interfaces (like <code>Predicate</code> here) and abstract classes. So the example can be further simplified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def items = filter(source) { it.length()&gt;3 } <b>(1)</b>
assert items == ['foobar']</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>note that <code>as Predicate</code> is not needed anymore!</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Can it be easier? Probably not, but maybe you noticed that this is close to what Java 8 will allow with lambdas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>List&lt;String&gt; items = filter(source, String str -&gt; str.length()&gt;3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you must be aware of some subtle differences with Java 8. One is that closures are <strong>not</strong> lambdas but instances of the <code>Closure</code> class (a subclass of <code>Closure</code>, to be precise), while lambdas are converted at <strong>compile time</strong> and can be directly implemented, for example, as methods (simple case) or anonymous inner classes. This difference implies that if you have:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def method(Closure c) { ... }
def method(SAMType arg) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then if you pass a closure as argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>method { ...do something... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the method which is chosen is the version which accepts a <code>Closure</code>, not the version accepting a <code>SAMType</code>. But since <code>Closure</code> implements <code>Runnable</code> and <code>Callable</code>, the same is true for those two interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>def method(Runnable c) { ... }
def method(SAMType arg) { ... }
method { ...do something... } // will call method(Runnable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that if you want to call the <code>SAMType</code> version, you still have to use explicit coercion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>method { ...do something... } as SAMType</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we exposed the basics of closure coercion, let&#8217;s come to the topic that gave its name to this blog post: performance.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance_of_coercion_vs_closure">Performance of coercion vs closure</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_gbench">GBench</h3>
<div class="paragraph">
<p>We will discuss here the impact of using closure coercion and compare the cost of implicit/explicit closure coercion as compared with calling a method which directly accepts a closure. For that, let&#8217;s start with the tool we&#8217;re going to use: <a href="https://code.google.com/p/gbench/">GBench</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://code.google.com/p/gbench/">GBench</a> is a project I really like and that I use a lot. It&#8217;s meant for micro-benchmarking. We know that micro-benchmarks are bad, but in some cases, they are useful. <a href="https://code.google.com/p/gbench/">GBench</a> makes them a little better by providing a framework that does all the boring stuff that you have to do when micro-benchmarking:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>setting up timers</p>
</li>
<li>
<p>warm up</p>
</li>
<li>
<p>repeat the execution of the same code N times</p>
</li>
<li>
<p>generation of a report</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All this using a nice DSL. If you want to write benchmarks, time execution of some process in your Groovy program, make sure to use it, it&#8217;s just the perfect tool.</p>
</div>
</div>
<div class="sect2">
<h3 id="_measurements">Measurements</h3>
<div class="paragraph">
<p>Now let&#8217;s proceed with the measurements. We want to compute the cost of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>directly accepting a closure as an argument</p>
</li>
<li>
<p>coercing the closure to a SAM type then calling</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For that, we&#8217;re just defining a very simple SAM type and two helper methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>interface SAMType {
    void apply()
}

@groovy.transform.CompileStatic
void direct(Closure c) { c.call() }

@groovy.transform.CompileStatic
void coercion(SAMType s) { s.apply() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two methods that will be called are compiled statically so that we made direct method calls inside the method body. This allows us to measure precisely the cost of calling the method, rather than the cost of dynamic dispatch. The measurements are made using this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>Closure cachedClosure = { 'do something' }
SAMType cachedSAMType = { 'do something' }

@Grab(group='org.gperfutils', module='gbench', version='0.4.2-groovy-2.1')
def r = benchmark {
      'explicit coercion' {
          coercion { 'do something' } as SAMType
      }
      'implicit coercion' {
          coercion { 'do something' }
      }
      'direct closure' {
          direct { 'do something' }
      }
      'cached SAM type' {
          coercion cachedSAMType
      }
      'cached closure' {
          direct cachedClosure
      }
  }
  r.prettyPrint()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that we are testing 5 cases here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>explicit coercion</code> calls the method accepting a <code>SAMType</code> with explicit coercion of a closure into a <code>SAMType</code></p>
</li>
<li>
<p><code>implicit coercion</code> does the same, without <code>as SAMType</code></p>
</li>
<li>
<p><code>direct closure</code> calls the method accepting a <code>Closure</code>. This means that this version will <strong>not</strong> involve any conversion.</p>
</li>
<li>
<p><code>cached SAM type</code> calls the <code>SAMType</code> version of the method with a coerced closure which is defined <strong>outside</strong> of the scope of the benchmark method</p>
</li>
<li>
<p><code>cached closure</code> calls the <code>Closure</code> version of the method with a closure which is defined <strong>outside</strong> of the scope of the benchmark method</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The last two versions are interesting because as I explained before, <a href="https://code.google.com/p/gbench/">GBench</a> automatically repeats the execution of the code N times. This means that this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>SAMType cachedSAMType = { 'do something' }
// ...
'cached SAM type' {
    coercion cachedSAMType
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is more or less equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>SAMType cachedSAMType = { 'do something' }
// ...
10000.times {
    coercion cachedSAMType
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So here is the result of the execution of this benchmark:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Environment
===========
* Groovy: 2.2.0-rc-3
* JVM: Java HotSpot(TM) 64-Bit Server VM (23.5-b02, Oracle Corporation)
    * JRE: 1.7.0_09
    * Total Memory: 679.4375 MB
    * Maximum Memory: 1765.375 MB
* OS: Linux (3.8.0-22-generic, amd64)

Options
=======
* Warm Up: Auto (- 60 sec)
* CPU Time Measurement: On

                   user  system   cpu  real

explicit coercion  1258       0  1258  1259
implicit coercion  1102      12  1114  1115
direct closure      318       5   323   324
cached SAM type     263       0   263   265
cached closure      259       0   259   261</pre>
</div>
</div>
<div class="paragraph">
<p>What you can see from those results is that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>using implicit closure coercion is slightly faster than explicit closure coercion</p>
</li>
<li>
<p>having a method which accepts directly a closure can significantly improve performance (almost 4x faster dispatch!)</p>
</li>
<li>
<p>using a cached closure or a cached SAM type is fast in any case</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that using cached closures is not something that is specific to Groovy: it would be true for any Java code too, if you consider a coerced closure as an anonymous inner class. Each time the method is called, you create a <strong>new instance</strong> of the closure (or, in Java, the anonymous inner class). So moving the definition of the closure (or anonymous inner class) outside the loop and you will reuse the <strong>same instance</strong>, dramatically improving performance.</p>
</div>
<div class="paragraph">
<p>We must explain what performance we&#8217;re talking about here: the closure does nothing special here, just returning a dummy string. So the cost of the treatment is almost null. What if the code actually does something? Would the differences be so important? To check that, we will modify the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>interface SAMType {
    void apply()
}

@groovy.transform.CompileStatic
void coercion(SAMType s) { s.apply() }

@groovy.transform.CompileStatic
void direct(Closure c) { c.call() }

void doSomething() {
   Thread.sleep(100)
}

Closure cachedClosure = { doSomething() }
SAMType cachedSAMType = { doSomething() }

@Grab(group='org.gperfutils', module='gbench', version='0.4.2-groovy-2.1')
def r = benchmark {
      'explicit coercion' {
          coercion { doSomething() } as SAMType
      }
      'implicit coercion' {
          coercion { doSomething() }
      }
      'direct closure' {
          direct { doSomething() }
      }
      'cached SAM type' {
          coercion cachedSAMType
      }
      'cached closure' {
          direct cachedClosure
      }
  }
  r.prettyPrint()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this version, we simulate a long running process with <code>Thread.sleep(100)</code>. The results are shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                     user  system     cpu       real

explicit coercion  248621       0  248621  100329258
implicit coercion  208407       0  208407  100273428
direct closure          0  166932  166932  100238245
cached SAM type         0  157406  157406  100232334
cached closure          0  160848  160848  100214197</pre>
</div>
</div>
<div class="paragraph">
<p>Note that it&#8217;s better to look at the <code>real</code> column here, since <code>Thread.sleep</code> doesn&#8217;t consume any CPU. What is interesting here is that now, there&#8217;s almost no difference between each version. This is simply explained: the cost of the treatment exceeds the cost of instantiating a closure and coercing it.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So given those figures, what can we conclude? First of all, one of the interests of implicit closure coercion is that previously (before Groovy 2.2), if you wanted users to avoid explicit coercion, you had to write a method accepting a closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>// real method
void addListener(Listener listener) { ... }
// convenience method to avoid explicit coercion from user code
void addListener(Closure cl) { addListener(cl as Listener) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is that you double the number of methods here, so implicit closure coercion is a big bonus here. But our figures showed that calling a method accepting a closure is much faster, so you have a dilemn here: should you keep the closure version or not? The second benchmark gives a first answer: you shouldn&#8217;t remove the <code>Closure</code> version only if you know that the treatment in the closure is <strong>very</strong> fast. As soon as business code in the closure is a bit complex, it&#8217;s not worth it and you can remove the <code>Closure</code> version. This means that in the vast majority of cases, you can remove it without problem.</p>
</div>
<div class="paragraph">
<p>In fact, there&#8217;s one more case where you&#8217;d want to keep the <code>Closure</code> version: if you manipulate the closure before calling it, like changing the delegate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint groovy language-groovy"><code>void doSomething(SAMType arg) { ... }
void doSomething(Closure cl) {
   def clone = cl.rehydrate(delegate,this,this)
   doSomething(clone as SAMType)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hope things are clearer for you now!</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2013/11/22/coercion_vs_direct.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2013/11/21/a_new_home.html"><h1>A new home!</h1></a>
  			<p>21 novembre 2013</p>
			<p><em>Tags: </em>blog </em> asciidoctor </em> jbake </p>
			<a href="https://twitter.com/share" class="twitter-share-button" data-text="A new home!" data-url="http://melix.github.io/blog/2013/11/21/a_new_home.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
			<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2013/11/21/a_new_home.html"></div>

  			<p><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Goodbye JRoller, welcome GitHub! Eventually, I migrated my blog to <a href="http://pages.github.com/">GitHub pages</a>. It is a now a statically generated website.
What is interesting here is how I migrated contents from my <a href="http://jroller.com/melix">old blog</a>. I used a <a href="http://groovy.codehaus.org">Groovy</a> script which
downloaded the old pages, converted them into <a href="http://asciidoctor.org">Asciidoctor</a> format so that they can be statically processed by <a href="http://jbake.org">JBake</a>.</p>
</div>
<div class="paragraph">
<p>Should you need something similar, I pushed this little toy here: <a href="https://github.com/melix/jroller-export">https://github.com/melix/jroller-export</a></p>
</div>
<div class="paragraph">
<p>Now the export is quite raw, there are probably minor rendering issues to fix, or broken links, and I still have to integrate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>twitter/google+ share buttons</p>
</li>
<li>
<p>comments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But this is another story!</p>
</div>
<div class="paragraph">
<p>Last but not least, this blog is also published on GitHub and all posts are published under <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/en/">Creative Commons by-nb-sa</a>.</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2013/11/21/a_new_home.html#disqus_thread">Comments</a></p>
  			<a href="/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html"><h1>deck2pdf: Exporting HTML5 slide decks to PDF</h1></a>
  			<p>30 juillet 2013</p>
			<p><em>Tags: </em>deckjs </em> dzslides </em> html5 </em> impressjs </em> javascript </em> pdf </em> revealjs </em> slideshow </p>
			<a href="https://twitter.com/share" class="twitter-share-button" data-text="deck2pdf: Exporting HTML5 slide decks to PDF" data-url="http://melix.github.io/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html" data-via="CedricChampeau" data-lang="fr">Tweeter</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
			<div class="g-plusone" data-size="medium" data-href="http://melix.github.io/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html"></div>

  			<p><div class="sect1">
<h2 id="_exporting_your_awesome_html5_presentation_to_pdf">Exporting your awesome HTML5 presentation to PDF</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For some time now, I’ve started using <a href="http://imakewebthings.com/deck.js/">deck.js</a> to write my talks. One of the reasons I do this is that it saves me <strong>lots</strong> of time when I have to copy and paste code, because I can rely on javascript code highlighting libraries to do the job. I can focus on contents instead of rendering. If I had a better knowledge of CSS, too, I could certainly write impressive presentations (but unfortunately, no, I’m not good at CSS).</p>
</div>
<div class="paragraph">
<p>The problem with HTML5 slideshows is that you are often asked to upload your slides as PDF. For example, <a href="https://speakerdeck.com/">SpeakerDeck</a>, <a href="http://www.slideshare.net/">SlideShare</a> or <a href="http://www.parleys.com/">Parleys</a> all require you to upload slides as PDF. None of them supports HTML5 (which is understandable because there are many frameworks available). While I did find some libraries that did the job (often in Perl or Ruby), I never managed to find one that actually worked properly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deck2pdf">Deck2pdf</h2>
<div class="sectionbody">
<div class="paragraph">
<p>That’s where it all started. I knew that JavaFX2 provided a WebView, which allowed rendering HTML pages with WebKit. What if I could use it to render my slide deck and export it to PDF? <a href="https://github.com/melix/deck2pdf">deck2pdf was born!</a>. I started with something that was able to export my <a href="http://imakewebthings.com/deck.js/">deck.js</a> presentations, but I figured out very quickly that it could support other HTML5 presentation libraries quite easily. As of today, <a href="https://github.com/melix/deck2pdf">deck2pdf</a> supports:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://imakewebthings.com/deck.js/">deck.js</a></p>
</li>
<li>
<p><a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
</li>
<li>
<p><a href="http://bartaz.github.io/impress.js">impress.js</a></p>
</li>
<li>
<p>and <a href="https://github.com/paulrouget/dzslides">DZSlides</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But more importantly, if your favorite HTML5 slideware is not supported, adding custom profiles is supported and fairly easy! Adding support for another library is as simple as adding a descriptor file with the javascript commands inside. For example, here’s how the <a href="http://imakewebthings.com/deck.js/">deck.js</a> profile is written:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>totalSlides=$.deck('getSlides').length
nextSlide=$.deck('next')
</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s all! Support for more complex interactions is also provided using Groovy profiles, like for example in <a href="http://bartaz.github.io/impress.js">impress.js</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code>setup = {
    js 'var api = impress();'
    js '''var $$ = function ( selector, context ) {
        context = context || document;
        return context.querySelectorAll(selector);
    };'''
    js '''var byId = function ( id ) {
        return document.getElementById(id);
    };'''
}

nextSlide = {
    js('api.next()')
}

totalSlides = {
    js (/$$(".step", byId('impress')).length/)
}

// longer pause because of transitions
pause = 2000
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, <a href="https://github.com/melix/deck2pdf">deck2pdf</a> is open source and licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html">APL2</a>. Feel free to fork it and contribute new profiles! The home page of the project has documentation explaining how you can create your own. I’m waiting for your pull requests!</p>
</div>
</div>
</div></p>
			<p><a href="/blog/2013/07/30/deck2pdf_exporting_html5_slide_decks.html#disqus_thread">Comments</a></p>
	
	<hr />
	
	<p>Older posts are available in the <a href="/blog/archive.html">archive</a>.</p>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
	<p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/2.0/fr/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2013 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v3.0.3</a> | Baked with <a href="http://jbake.org">JBake v2.2.1-SNAPSHOT</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/blog/js/jquery-1.9.1.min.js"></script>
    <script src="/blog/js/bootstrap.min.js"></script>
    <script src="/blog/js/run_prettify.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <script type="text/javascript">
    var disqus_shortname = 'melixblog';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
<script type="text/javascript">
  window.___gcfg = {lang: 'fr'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45962373-1', 'melix.github.io');
  ga('send', 'pageview');

</script>
<script src="http://cdn.lanyrd.net/badges/person-v1.min.js"></script>
  </body>
</html>
