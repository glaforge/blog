<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cédric Champeau's blog</title>
    <link>http://melix.github.io/blog/</link>
    <atom:link href="http://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>jeu., 6 mars 2014 18:55:37 +0100</pubDate>
    <lastBuildDate>jeu., 6 mars 2014 18:55:37 +0100</lastBuildDate>

    <item>
      <title>A fast markup template engine for Groovy (part 2 of 2)</title>
      <link>http://melix.github.io/blog//2014/02/markuptemplateengine_part2.html</link>
      <pubDate>mar., 18 févr. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2014/02/markuptemplateengine_part2.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, I will discuss the implementations details for the markup template engine I have described in a &lt;a href=&quot;/blog/2014/02/markuptemplateengine.html&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_compiling_templates&quot;&gt;Compiling templates&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_markuptemplateengine_class&quot;&gt;The MarkupTemplateEngine class&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Even if my first implementation of the markup template engine was relying on &lt;code&gt;StreamingMarkupBuilder&lt;/code&gt;, the technique used to compile templates into bytecode is actually the same after all optimizations. It relies on:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/lang/GroovyClassLoader.html&quot;&gt;GroovyClassLoader&lt;/a&gt; to create and cache template classes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a &lt;a href=&quot;http://groovy.codehaus.org/api/org/codehaus/groovy/control/CompilerConfiguration.html&quot;&gt;CompilerConfiguration&lt;/a&gt; to customize compilation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The various template engines that Groovy provide extend the &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/text/TemplateEngine.html&quot;&gt;TemplateEngine&lt;/a&gt; class. All template engines must implement the &lt;code&gt;createTemplate&lt;/code&gt; method which returns an instance of &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/text/Template.html&quot;&gt;Template&lt;/a&gt;. My first idea, here, was therefore to have a template engine which holds a &lt;code&gt;GroovyClassLoader&lt;/code&gt;, and compiles scripts as &lt;code&gt;Template&lt;/code&gt; instances. For thread safety reasons and to avoid compiling the same template again and again, I instead chose a slightly different approach, which is to compile the scripts, and cache the resulting class into a field of the &lt;code&gt;StreamingMarkupBuilderTemplate&lt;/code&gt; class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;    private class StreamingMarkupBuilderTemplate implements Template {
        final Class&amp;lt;BaseTemplate&amp;gt; templateClass;							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

        public StreamingMarkupBuilderTemplate(final Reader reader) {
            templateClass = groovyClassLoader.parseClass(
		new GroovyCodeSource(reader, &quot;GeneratedMarkupTemplate&quot; + counter.getAndIncrement(), &quot;&quot;));
        }

        public StreamingMarkupBuilderTemplate(final URL resource) throws IOException {
            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(resource));
        }

        public Writable make() {
            return make(Collections.emptyMap());							&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        }

        public Writable make(final Map binding) {
            return DefaultGroovyMethods.newInstance(templateClass,
		new Object[]{MarkupTemplateEngine.this, binding, templateConfiguration});		&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
        }
    }&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;templateClass&lt;/code&gt; corresponds to the user script, compiled as a template class&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make&lt;/code&gt; binds a model to the template&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make&lt;/code&gt; instantiates a new template and binds the model to it&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; method is very important. It returns a &lt;code&gt;Writable&lt;/code&gt; which will trigger template rendering when &lt;code&gt;writeTo&lt;/code&gt; is called. Therefore, nothing is rendered until the &lt;code&gt;Writable#writeTo&lt;/code&gt; method is called. The only thing that &lt;code&gt;bind&lt;/code&gt; does is instantiating a new template. As we are using a cached class, there&amp;#8217;s no compilation involved anymore, so the template is compiled once for all.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_basetemplate_class&quot;&gt;The BaseTemplate class&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, the user script is compiled into a class which extends &lt;code&gt;BaseTemplate&lt;/code&gt;. This means that the following script:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;page.tpl&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;html {
   body {
      p(&quot;I&apos;m a template&quot;)
   }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;compiles to a class extending &lt;code&gt;BaseTemplate&lt;/code&gt;. If you are familiar with &lt;code&gt;GroovyClassLoader&lt;/code&gt; or &lt;code&gt;GroovyShell&lt;/code&gt;, you should actually know that normally, a script compiles to a class extending &lt;a href=&quot;http://groovy.codehaus.org/api/groovy/lang/Script.html&quot;&gt;Script&lt;/a&gt;. In our case, we don&amp;#8217;t want to extend &lt;code&gt;Script&lt;/code&gt;, because it does things that we don&amp;#8217;t want, such as overriding &lt;code&gt;getProperty&lt;/code&gt; or using a &lt;code&gt;Binding&lt;/code&gt; class, or even having the semantics of a Groovy script. Furthermore, it doesn&amp;#8217;t allow us to have a custom constructor to have private final fields. So the first step of our compilation process is actually to change the super class of the compiled script. The next step is to create a constructor that takes our model and the template configuration as parameters, as seen in the &lt;code&gt;make&lt;/code&gt; method. Last but not least, since the script being compiled defines a &lt;code&gt;run&lt;/code&gt; method (which is abstract in &lt;code&gt;Script&lt;/code&gt;) corresponding to the script body, we will perform additional code transformations on this specific method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;@Override
    public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
        if (classNode.isScriptBody()) {							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
            classNode.setSuperClass(MarkupTemplateEngine.BASETEMPLATE_CLASSNODE);	&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
            createConstructor(classNode);						&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
            transformRunMethod(classNode, source);					&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;a Groovy script may contain multiple class, so we need to check if the current class is actually the script body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we change the super class from &lt;code&gt;Script&lt;/code&gt; to &lt;code&gt;BaseTemplate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we create a new constructor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we perform code modifications on the script body&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_implementing_the_builder&quot;&gt;Implementing the builder&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;transformRunMethod&lt;/code&gt; method is actually an example of how to implement a Groovy DSL using AST transformations. The goal of this method is to alter the AST (abstract syntax tree), so that some method calls in source code, for example, are actually rewritten. It is also the starting point of performance optimizations. This is actually very important. For example, one of the transformations will change:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(text)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(getModel().get(&quot;text&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Technically speaking, there is no need to do such a change: we could rely on &lt;code&gt;BaseTemplate&lt;/code&gt; implementing &lt;code&gt;propertyMissing&lt;/code&gt; to resolve missing variables (here, &lt;code&gt;text&lt;/code&gt;) and delegate the call to its internal &lt;code&gt;model&lt;/code&gt; field. However, this can be particularily slow, especially in builders where there are lots of nested closures, which involve a very long call chain. By doing this change, we transform a so-called &lt;code&gt;DynamicVariable&lt;/code&gt; (&lt;code&gt;text&lt;/code&gt;) into something that can be resolved statically (&lt;code&gt;getModel&lt;/code&gt; is declared in &lt;code&gt;BaseTemplate&lt;/code&gt; and is of type &lt;code&gt;Map&lt;/code&gt;). Slowly, we&amp;#8217;re making a switch towards &lt;strong&gt;statically compilable&lt;/strong&gt; code&amp;#8230; but we&amp;#8217;re not there yet.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In classic builder code, compiling this would work and eventually, when the &lt;code&gt;p&lt;/code&gt; method is called, the meta-object protocol goes into action and eventually calls the &lt;code&gt;methodMissing&lt;/code&gt; method on the &lt;code&gt;BaseTemplate&lt;/code&gt; class if it is defined. So to make our code work, all we have to do is to write that method:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;BaseTemplate.java&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    public Object methodMissing(String tagName, Object args) throws IOException {
        Object o = model.get(tagName);
        if (args instanceof Object[]) {
            final Writer wrt = out;
            TagData tagData = new TagData(args).invoke();
            Object body = tagData.getBody();
            writeIndent();
            wrt.write(&apos;&amp;lt;&apos;);
            wrt.write(tagName);
            writeAttributes(tagData.getAttributes());
            if (body != null) {
                wrt.write(&apos;&amp;gt;&apos;);
                writeBody(body);
                writeIndent();
                wrt.write(&quot;&amp;lt;/&quot;);
                wrt.write(tagName);
                wrt.write(&apos;&amp;gt;&apos;);
            } else {
                if (configuration.isExpandEmptyElements()) {
                    wrt.write(&quot;&amp;gt;&amp;lt;/&quot;);
                    wrt.write(tagName);
                    wrt.write(&apos;&amp;gt;&apos;);
                } else {
                    wrt.write(&quot;/&amp;gt;&quot;);
                }
            }
        }
        return this;
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can test that this code works by rendering a simple template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
	p(text)
    }
}
&apos;&apos;&apos;
def model = [text:&apos;It works!&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What is nice is that we can also rely on the template configuration to perform different transformations. For example, there&amp;#8217;s an optional &lt;code&gt;autoEscape&lt;/code&gt; flag which tells if variables read from the model should be automatically escaped. If the flag is set to false, the following code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;is transformed into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;getModel().get(&quot;text&quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but if the flag is set to true, the generated code is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;yield(getModel().get(&quot;text&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;where &lt;code&gt;yield&lt;/code&gt; is the method which will escape contents&amp;#8230; So it&amp;#8217;s a very flexible way to perform parametrized transformations of templates! The same technique is used to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;include (template|escaped|unescaped):&apos;path/to/template&apos;&lt;/code&gt; into `include(Groovy|Escaped|Unescaped)(&lt;em&gt;/path/to/template&lt;/em&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;unescaped.foo&lt;/code&gt; into &lt;code&gt;getModel().get(&quot;foo&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transform &lt;code&gt;&apos;:XXX&apos;()&lt;/code&gt; method calls into &lt;code&gt;methodMissing(&apos;XXX&apos;, ...)&lt;/code&gt;. This gives a way to render tags which have the same name as helper methods like &lt;code&gt;yield&lt;/code&gt;. In that case, the user can write &lt;code&gt;&apos;:yield&apos;()&lt;/code&gt; to create a tag &lt;code&gt;&amp;lt;yield&amp;gt;&lt;/code&gt; instead of calling the &lt;code&gt;yield&lt;/code&gt; method for example.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_statically_compiling_templates&quot;&gt;Statically compiling templates&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_oops_i_did_it_again&quot;&gt;Oops, I did it again!&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Going further towards statically compilable code requires additional trickery. In the previous example, we still have a call (&lt;code&gt;p(...)&lt;/code&gt;) which is &lt;em&gt;unresolved&lt;/em&gt;, goes through the MOP and eventually calls &lt;code&gt;methodMissing&lt;/code&gt;. The same way we converted the &lt;code&gt;text&lt;/code&gt; variable into a dynamic call, we can make it statically compilable. Since the method which would eventually be called would be &lt;code&gt;methodMissing&lt;/code&gt;, instead of going through the MOP, since we know that this particular method will always be called in our case, we can directly make the change, and hardwire it. The resulting code would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodMissing(&quot;p&quot;, new Object[]{getModel().get(&quot;text&quot;)})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This change can be made in our transformer, like we did the &lt;code&gt;getModel&lt;/code&gt; change. However, we will see that we have a serious problem with that. Meanwhile, let&amp;#8217;s show how we can trigger static compilation of templates. This can be done easily by injecting the &lt;code&gt;@CompileStatic&lt;/code&gt; annotation through &lt;code&gt;CompilerConfiguration&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;compilerConfiguration.addCompilationCustomizers(new TemplateASTTransformer(tplConfig)); 		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
compilerConfiguration.addCompilationCustomizers(
                new ASTTransformationCustomizer(CompileStatic.class));					&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply the AST transformations to rewrite unresolved variables and method missing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply &lt;code&gt;@CompileStatic&lt;/code&gt; to the template&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can try the template engine using the same code as before:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
    p(text)
    }
}
&apos;&apos;&apos;
def model = [text:&apos;It works!&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And it works! So what is the problem? Actually, there are multiple issues. The first one is that you can&amp;#8217;t call existing methods anymore! For example, we can&amp;#8217;t call the &lt;code&gt;yield&lt;/code&gt; method because it has been converted too:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;yield &apos;Some text&apos;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;gets converted into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodMissing(&quot;yield&quot;, new Object[] {&quot;Some &amp;lt;text to escape&amp;gt;&quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and eventually generates this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint xml language-xml&quot;&gt;&lt;code&gt;&amp;lt;yield&amp;gt;Some &amp;lt;text to escape&amp;gt;&amp;lt;/yield&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Is it the end of the story? Can&amp;#8217;t we really statically compile our templates and make them super fast? Well, no, of course!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is where all the magic begins. Solving this problem requires being able to make a difference between calls to methods which &lt;strong&gt;exist&lt;/strong&gt; (like &lt;code&gt;yield&lt;/code&gt;) and calls to methods which are not defined (like &lt;code&gt;html&lt;/code&gt;). And guess what, Groovy has a very nice tool whose responsability is &lt;strong&gt;exactly&lt;/strong&gt; this: static type checking and by extension, static compilation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So let&amp;#8217;s start by removing the code which transforms the method calls into &lt;code&gt;methodMissing&lt;/code&gt; calls, and try to compile the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTemplate &apos;&apos;&apos;
html {
    body {
        yield text
    }
}
&apos;&apos;&apos;
def model = [text:&apos;Text &amp;lt;to be escaped&amp;gt;&apos;]
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since we kept static compilation, it will fail, but it will give us interesting information:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - Cannot find matching method GeneratedMarkupTemplate6#html(groovy.lang.Closure). Please check if the declared type is right and if the method exists.
 at line: 2, column: 1

[Static type checking] - Cannot find matching method GeneratedMarkupTemplate6#body(groovy.lang.Closure). Please check if the declared type is right and if the method exists.
 at line: 3, column: 5&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What we see is that the two errors are precisely the methods that we want to directly wire to &lt;code&gt;methodMissing&lt;/code&gt;. The &lt;code&gt;yield&lt;/code&gt; method has been recognized, so the type checker did the job for us. It is telling us: &quot;ok guys, there are two method calls I know nothing about. Those are &lt;code&gt;html&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;. Please do something or I can&amp;#8217;t compile it.&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s nice, but how can I help the compiler?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_type_checking_extensions&quot;&gt;Type checking extensions&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, this is precisely why type checking extensions were added in Groovy 2.1. They allow the programmer to help the compiler when he knows about a method call that the type checker isn&amp;#8217;t able to resolve. You can give hints and tell &quot;ok, this method exists, and it returns an object of type Foo&quot;. In Groovy 2.2, this mechanism was extended to static compilation, which opens another chapter in the incredible extensibility that Groovy has to offer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Writing type checking extensions require a bit of knowledge of the Groovy AST (abstract syntax tree), so anyone who ever wrote an AST transformation in Groovy should be capable of writing a type checking extension. Actually, it is even easier, and the process is described &lt;a href=&quot;http://docs.codehaus.org/display/GROOVY/Type+checking+extensions&quot;&gt;here&lt;/a&gt;. In our case, we will start leveraging a feature of Groovy 2.2 will allows us to mix dynamic code with statically compiled code. That is to say that the only thing that our extension is going to do is saying &quot;when you don&amp;#8217;t know what a method call does, perform a dynamic invocation&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When we added this to Groovy 2.2, we really didn&amp;#8217;t want to make &quot;mixed&quot; mode a first class citizen in static compilation, because it defeats the idea of catching typos, which is one of the things people expect most from a type checking system. So this &quot;mixed&quot; mode is actually activated by type checking extensions. This means that the only method calls which will be made dynamic will be those that the programmer knows about, and really wants to convert to dynamic calls. It is an important difference, because we want the developper to be &lt;strong&gt;aware&lt;/strong&gt; of what he is doing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That said, how can we implement that? It&amp;#8217;s actually pretty easy. The first thing to do is to write the code which will help the compiler:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;	&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    if (call.lineNumber &amp;gt; 0) {					&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
        if (call.implicitThis) {				&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
            return makeDynamic(call, OBJECT_TYPE)		&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;react to the &lt;code&gt;methodNotFound&lt;/code&gt; event, thrown by the type checker&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;make sure the event is called on user code, that is to say code for which there&amp;#8217;s an associated line number&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;make sure that only calls which are on an &quot;implicit this&quot; are made dynamic (see below)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;instruct the compiler to perform a dynamic call here&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Point 3 is actually important. We said that we wanted the developper to be aware of which calls he want to make dynamic. This is the kind of guards that you might want to add. In builder-style code, only method calls for which there&amp;#8217;s no explicit receiver should be considered as method creating tags. For example, if you write &lt;code&gt;this.foo&lt;/code&gt;, there is an &lt;strong&gt;explicit&lt;/strong&gt; &lt;code&gt;this&lt;/code&gt; receiver, and we don&amp;#8217;t want to convert that call. Instead, we want to let the compiler report an error.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that the extension is written, we still have to load it. There are two ways of loading type checking extensions: using scripts (Groovy 2.1) or precompiled type checking extensions (Groovy 2.2+). In my case, I wanted to use precompiled type checking extensions, to avoid paying the cost of compiling the type checking extension at runtime. This can be done by wrapping the extension script into a class extending &lt;code&gt;GroovyTypeCheckingExtensionSupport.TypeCheckingDSL&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class MarkupTemplateTypeCheckingExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {

    @Override
    Object run() {
	methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;
		...
	}
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then the extension can be loaded by slightly changing the way we activate &lt;code&gt;@CompileStatic&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;compilerConfiguration.addCompilationCustomizers(
        new ASTTransformationCustomizer(
            Collections.singletonMap(&quot;extensions&quot;,&quot;groovy.text.markup.MarkupTemplateTypeCheckingExtension&quot;), &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
            CompileStatic.class));									     &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;create the map of arguments for the &lt;code&gt;@CompileStatic&lt;/code&gt; AST transformation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply &lt;code&gt;@CompileStatic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_improving_performance&quot;&gt;Improving performance&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With the type checking extension, we&amp;#8217;ve now instructed the compiler to perform &lt;strong&gt;dynamic&lt;/strong&gt; calls when it finds tag methods. All other calls, which were resolved statically, are made static. This is nice, but we are still paying the price of the meta-object protocol here, and there&amp;#8217;s no reason to go through a dynamic path were we want the target method to be &lt;code&gt;methodMissing&lt;/code&gt; in any case. So, how can we solve that?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock warning&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;icon-warning&quot; title=&quot;Warning&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
Before going further, you have to be warned. What I am going to show you is things that I wouldn&amp;#8217;t recommand for beginners in AST transformations. We&amp;#8217;re going to update the AST &lt;strong&gt;just before it is going to generate bytecode&lt;/strong&gt;. This is very late in the compilation process, meaning that you are walking along a thin rope without net! Traditional AST transformations run much earlier in the compilation process, and the compiler will do a lot of things for you (like resolving methods, variables, &amp;#8230;). Here, it is so late that all those things have already been done, so you have to do it all yourself!
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let the fun begin! The idea is quite simple actually. Instead of relying on &lt;code&gt;makeDynamic&lt;/code&gt;, we will transform the calls into direct calls to &lt;code&gt;methodMissing&lt;/code&gt;. The type checking extension API doesn&amp;#8217;t let you do this (it&amp;#8217;s not meant to transform the AST), so you have to do it yourself. This involves multiple steps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;when we start visiting a method, create an empty list of method calls that will need to be transformed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;when an unresolved call is found and that it matches our criteria, put that call into the list&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;after the method has been visited, trigger a transformer which will transform all calls in the list&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first step requires an extra block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;beforeVisitMethod {		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   newScope {			&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      builderCalls = []		&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we&amp;#8217;re entering a new method body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;newScope&lt;/code&gt; pushes a &quot;type checking scope&quot; on stack, where you can put user data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;add the &lt;code&gt;builderCalls&lt;/code&gt; method to this scope&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then you can add the method calls to be transformed this way:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;methodNotFound { receiver, name, argList, argTypes, call -&amp;gt;
    if (call.lineNumber &amp;gt; 0) {
        if (call.implicitThis) {
            currentScope.builderCalls &amp;lt;&amp;lt; call
            return makeDynamic(call, OBJECT_TYPE)
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And triggering the AST transformation can be done in an &lt;code&gt;afterVisitMethod&lt;/code&gt; block:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;afterVisitMethod { mn -&amp;gt;							&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
   scopeExit {									&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
      new BuilderMethodReplacer(context.source, builderCalls).visitMethod(mn)	&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;when we exit a method body&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;pop the current scope from stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;trigger an AST transformation which will visit this method knowing which calls need to be transformed&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, we still miss the transformation code. For that, we need a class which extends &lt;a href=&quot;http://groovy.codehaus.org/api/org/codehaus/groovy/ast/ClassCodeExpressionTransformer.html&quot;&gt;ClassCodeExpressionTransformer&lt;/a&gt; :&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;    private static class BuilderMethodReplacer extends ClassCodeExpressionTransformer {

        private static final MethodNode METHOD_MISSING = ClassHelper.make(BaseTemplate).getMethods(&apos;methodMissing&apos;)[0]		&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;

        private final SourceUnit unit;
        private final Set&amp;lt;MethodCallExpression&amp;gt; callsToBeReplaced;

        BuilderMethodReplacer(SourceUnit unit, Collection&amp;lt;MethodCallExpression&amp;gt; calls) {
            this.unit = unit
            this.callsToBeReplaced = calls as Set;
        }

        @Override
        protected SourceUnit getSourceUnit() {
            unit
        }

        @Override
        void visitClosureExpression(final ClosureExpression expression) {
            super.visitClosureExpression(expression)
        }

        @Override
        public Expression transform(final Expression exp) {
            if (callsToBeReplaced.contains(exp)) {									&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
                def args = exp.arguments instanceof TupleExpression ? exp.arguments.expressions : [exp.arguments]
                args*.visit(this)
                // replace with direct call to methodMissing
                def call = new MethodCallExpression(									&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
                        new VariableExpression(&quot;this&quot;),
                        &quot;methodMissing&quot;,
                        new ArgumentListExpression(
                                new ConstantExpression(exp.getMethodAsString()),
                                new ArrayExpression(
                                        OBJECT_TYPE,
                                        [* args]
                                )
                        )
                )
                call.implicitThis = true
                call.safe = exp.safe
                call.spreadSafe = exp.spreadSafe
                call.methodTarget = METHOD_MISSING									&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
                call													&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
            } else if (exp instanceof ClosureExpression) {
                exp.code.visit(this)
                super.transform(exp)
            } else {
                super.transform(exp)
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;find the method which will eventually be called, &lt;code&gt;methodMissing&lt;/code&gt; and keep a handle on it&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;when an expression is visited, we check if it is a method call which should be replaced&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;create a new method call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;link the call to its target method (very important if you don&amp;#8217;t want to crash the compiler!)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;return the new method call&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And we&amp;#8217;re done! Of course, I didn&amp;#8217;t say it was trivial nor easy, yet, it is possible, and now, all methods supposed to create a tag are directly wired to &lt;code&gt;methodMissing&lt;/code&gt;, meaning that they are now statically compiled!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_more_things_to_fix&quot;&gt;More things to fix&amp;#8230;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You may think that all problems are solved, but in fact, there are still issues with this code. Imagine the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(text.toUpperCase())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you compile it, it will fail with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The reason is that we compile the template statically. While we instructed the compiler that &lt;code&gt;text&lt;/code&gt; is in fact &lt;code&gt;getModel().get(&quot;text&quot;)&lt;/code&gt;, it is still unable to know what is the return type of this call. Then, it assumes that it returns an &lt;code&gt;Object&lt;/code&gt;, and if you try to call &lt;code&gt;toUpperCase&lt;/code&gt; on an &lt;code&gt;Object&lt;/code&gt;, the method doesn&amp;#8217;t exist&amp;#8230; This can easily be solved, by making all unresolved method calls dynamic. This means that the template compilation will never throw such errors anymore, but it will instead make a dynamic call. Problem solved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, almost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What if I do this?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(((String)text).toUpperCase())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then, by adding a cast, the static compiler is able to resolve the method call. Instead of doing a dynamic call, like it would with our extension, it will perform a direct method call, which will be faster! This means that if you add types, by casting, to your template, rendering can be made faster.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is an interesting idea, but it is not really user friendly. So the last thing I added to the type checking extension is actually an optional, &quot;type checked&quot; mode. If this mode is activated, then the programmer is supposed to tell which are the types of the elements found into the binding. Here, the developper would have to declare that &lt;code&gt;text&lt;/code&gt; is of type String:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate = engine.createTypeCheckedModelTemplate &apos;&apos;&apos;				&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
p {
   yield text.toUpperCase()								&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
}
&apos;&apos;&apos;, [text:&apos;String&apos;]
def model = [text:&apos;Text &amp;lt;to be escaped&amp;gt;&apos;]						&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
mkpTemplate.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;use &lt;code&gt;createTypeCheckedModelTemplate&lt;/code&gt; instead of &lt;code&gt;createTemplate&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;you can use &lt;code&gt;text.toUpperCase()&lt;/code&gt; without an explicit cast&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;because the model was declared using a simple map&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This mode is actually very interesting if you want to report template errors at &lt;em&gt;template compilation&lt;/em&gt; time. Instead of having an error when the template is rendered, the error will occur at compile time. So, for example, if we change the model declaration from:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[text:&apos;String&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[text:&apos;Integer&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;template compilation will now fail with:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - Cannot find matching method java.lang.Integer#toUpperCase(). Please check if the declared type is right and if the method exists.&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What is really interesting is that you can declare &quot;complex&quot; models, like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;[persons:&apos;List&amp;lt;Person&amp;gt;&apos;, posts:[List&amp;lt;Post&amp;gt;]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and have the template statically compiled! The implementation details of that mode are a bit complex, but you can take a look at the &lt;a href=&quot;https://github.com/melix/groovy-core/commit/30096837f8494d64d249a3341efca7ea66bb816f&quot;&gt;commit&lt;/a&gt; if you want to have some hint (don&amp;#8217;t hesitate to ask me if you want me to explain how it works).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_and_more_features&quot;&gt;And more features!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, the template engine implements automatic indent and automatic new lines. The first one is quite easy to implement, as it only requires wrapping the supplied &lt;code&gt;Writer&lt;/code&gt; into an &lt;code&gt;IndentWriter&lt;/code&gt;. But adding automatic new lines is a bit trickier, because we want to rely on the layout of the source code to actually add behavior! Let me explain that again with examples. If you have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {
  p(&apos;text&apos;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;we want to render:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;Text&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But if we have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {  p(&apos;text&apos;) }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We want to render:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;p&amp;gt;Text&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem is that our templates are actually Groovy code&amp;#8230; And new lines are not significant. They are not even visible in the AST, so how can we implement such a feature?! The answer relies in each AST node&amp;#8230; They all carry line and column number information. So, by comparing, in a &lt;code&gt;ClosureExpression&lt;/code&gt;, the line number of the closure itself with the line number of its first code statement, we can determine if there was a new line in source code! The same way, we can check if the last line number of the closure is greater than the line number of the last statement, and if so, introduce a new line&amp;#8230; So, in the first example, the code is actually transformed into:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;div {
  newLine()
  p(&apos;text&apos;)
  newLine()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And that&amp;#8217;s it!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this (long) blog post, I have demonstrated various techniques that allowed me to transform a slow, dynamic builder based template engine into a fast, statically compiled, template engine with optional user model type checking and unique features like automatic new line insertions. It goes far beyond what the &lt;code&gt;StreamingMarkupBuilder&lt;/code&gt; has to offer and demonstrates that compile time metaprogramming can be used in Groovy to provide advanced features. Of course, no one would expect you to create such code from the beginning. If you &lt;a href=&quot;https://github.com/melix/groovy-core/commits/markup-template-engine&quot;&gt;take a look at the branch commits&lt;/a&gt;, you will definitely see that I went step by step. And eventually, I will issue a pull request when I think that the code is ready for prime time. I am not sure yet this should make into core groovy, or instead if it should go into an external project. Ideas are welcome!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I still have to make some changes, like not reporting errors if the type checking mode is not active (and always going through dynamic mode in that case) and probably write more benchmarks, but I&amp;#8217;m really looking forward to read what you think. Oh yes, one last thing: congratulations if you read that post throughfully!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A fast markup template engine for Groovy (part 1 of 2)</title>
      <link>http://melix.github.io/blog//2014/02/markuptemplateengine.html</link>
      <pubDate>dim., 16 févr. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2014/02/markuptemplateengine.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Recently, I was &lt;a href=&quot;https://twitter.com/CedricChampeau/status/431131840788041728&quot;&gt;surprised&lt;/a&gt; no-one had the idea of developping a template engine relying on the Groovy &lt;a href=&quot;http://groovy.codehaus.org/Creating+XML+using+Groovy&amp;#8217;s+MarkupBuilder&quot;&gt;MarkupBuilder&lt;/a&gt;. Working on &lt;a href=&quot;http://jbake.org/&quot;&gt;JBake&lt;/a&gt; made me take a look at existing template engines for Java again, something I hadn&amp;#8217;t done for years, and even if new technologies like &lt;a href=&quot;http://www.thymeleaf.org/&quot;&gt;Thymeleaf&lt;/a&gt; or &lt;a href=&quot;http://jknack.github.io/handlebars.java/gettingStarted.html&quot;&gt;Handlebars&lt;/a&gt; exist, not of them are as practical to use as the markup builder.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_an_interesting_experiment&quot;&gt;An interesting experiment&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For that reason, I started working on a new template engine leveraging Groovy. The primary focus of this template engine would be XML-like markup (XHTML, HTML5, XML, &amp;#8230;), but in theory, it can be used to render anything. The basic idea is that you can write a template which looks like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
    body {
        yield message			&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;message&lt;/em&gt; is a template variable&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;which renders to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It works!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;My first implementation was done quickly done and was leveraging the &lt;a href=&quot;http://groovy.codehaus.org/gapi/groovy/xml/StreamingMarkupBuilder.html&quot;&gt;StreamingMarkupBuilder&lt;/a&gt;. It wasn&amp;#8217;t very difficult to write, but it had a problem: in general, builders are quite slow, so not very suitable for templating engines, where you should render a page as fast as possible. To check this, I wrote a simple micro-benchmark, which compared my template engine with Freemarker:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;@Grab(group=&apos;org.gperfutils&apos;, module=&apos;gbench&apos;, version=&apos;0.4.2-groovy-2.1&apos;)
@Grab(&apos;org.freemarker:freemarker:2.3.9&apos;)
import groovy.text.markup.MarkupTemplateEngine
import freemarker.template.*

MarkupTemplateEngine engine = new MarkupTemplateEngine()
def mkpTemplate1 = engine.createTemplate &apos;&apos;&apos;
html {
    body(&apos;It works!&apos;)
}
&apos;&apos;&apos;
def mkpTemplate2 = engine.createTemplate &apos;&apos;&apos;
html {
    body(text)
}
&apos;&apos;&apos;

def mkpTemplate3 = engine.createTemplate &apos;&apos;&apos;
html {
    body(text.toUpperCase())
}
&apos;&apos;&apos;

def cfg = new Configuration()
def ftlTemplate1 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It works!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def ftlTemplate2 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;${text}&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def ftlTemplate3 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;${text?upper_case}&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def r = benchmark {
    &apos;MarkupTemplateEngine (simple, no binding)&apos; { mkpTemplate1.make([:]).writeTo(new StringWriter()) }
    &apos;Freemarker (simple, no binding)&apos; { ftlTemplate1.process([:], new StringWriter()) }
    &apos;MarkupTemplateEngine (simple binding)&apos; { mkpTemplate2.make([text:&apos;Hello&apos;]).writeTo(new StringWriter()) }
    &apos;Freemarker (simple binding)&apos; { ftlTemplate2.process([text:&apos;Hello&apos;], new StringWriter()) }
    &apos;MarkupTemplateEngine (simple toUpper)&apos; { mkpTemplate3.make([text:&apos;Hello&apos;]).writeTo(new StringWriter()) }
    &apos;Freemarker (simple toUpper)&apos; { ftlTemplate3.process([text:&apos;Hello&apos;], new StringWriter()) }
}

r.prettyPrint()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I expected my template engine to be slower, yet I didn&amp;#8217;t expect it to be &lt;strong&gt;that&lt;/strong&gt; slow:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;                                            user  system    cpu   real

MarkupTemplateEngine (simple, no binding)  23038       0  23038  23059
Freemarker (simple, no binding)              385       0    385    392
MarkupTemplateEngine (simple binding)      26221       0  26221  26244
Freemarker (simple binding)                 1037       1   1038   1046
MarkupTemplateEngine (simple toUpper)      26895       0  26895  26929
Freemarker (simple toUpper)                 1161       0   1161   1171&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As wisdom says, make it work, make it right, then make it fast. I already had it working and it did what I wanted, so the next logical step would therefore be optimizing&amp;#8230; But before I show you the results of that steps, let&amp;#8217;s take a look at the features I have implemented so far.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_features&quot;&gt;Features&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I am quite happy with the current feature set, which I think is good enough for a public review. Here is a quick list.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_builder_syntax&quot;&gt;builder syntax&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;html {
   head {
      meta(charset:&apos;utf-8&apos;)
      title(&apos;Page title&apos;)
   }
}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Renders to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&amp;lt;title&amp;gt;Page title&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For that, the code to initialize the template engine is quite simple (note that you can use it in Java too):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.text.markup.MarkupTemplateEngine
import groovy.text.markup.TemplateConfiguration

def tplConf = new TemplateConfiguration()
MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, tplConf)

def mkpTemplate1 = engine.createTemplate &apos;&apos;&apos;
html {
   head {
      meta(charset:&apos;utf-8&apos;)
      title(&apos;Page title&apos;)
   }
}
&apos;&apos;&apos;

def model = [:]

mkpTemplate1.make(model).writeTo(new PrintWriter(System.out))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_groovy_goodness&quot;&gt;Groovy goodness&lt;/h3&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;ul {
   persons.each { p -&amp;gt;
   	li(p.name)
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With the following model:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def model = [persons: [new Person(name:&apos;Bob&apos;), new Person(name:&apos;Alice&apos;)]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Renders to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;Bob&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;Alice&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_template_inclusion&quot;&gt;template inclusion&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_inclusion_of_another_template&quot;&gt;inclusion of another template&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   include template: &apos;includes/header.tpl&apos;
   include template: &apos;includes/body.tpl&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_inclusion_of_escaped_text&quot;&gt;inclusion of escaped text&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   div(class:&apos;post&apos;) {
   	include escaped: &apos;content/text.txt&apos;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_inclusion_of_unescaped_text&quot;&gt;inclusion of unescaped text&lt;/h4&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   div(class:&apos;post&apos;) {
   	include unescaped: &apos;content/raw.txt&apos;
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_automatic_escaping_of_user_input&quot;&gt;automatic escaping of user input&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By default, variables read from the model will be escaped. For example, given the following model:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def model = [text:&apos;&amp;lt;html&amp;gt;&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(text)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then the result will be:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;amp;lt;html&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is possible to avoid escaping by prefixing the variable name with &lt;code&gt;unescaped.&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;p(unescaped.text)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_automatic_indentation&quot;&gt;automatic indentation&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Automatic indentation allows the programmer to get rid of indent instructions. For the following template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   newLine()
   body {
newLine()
p(&apos;Auto indent in action!&apos;)
newLine()
   }
   newLine()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The result without automatic indent is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;Auto indent in action!&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If auto-indent is activated, then the output is changed to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;p&amp;gt;Auto indent in action!&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_automatic_new_lines&quot;&gt;automatic new lines&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The previous example was nice, but you have a lot of &lt;code&gt;newLine&lt;/code&gt; method calls. Activating auto-newline will use the open blocks to introduce newLines automatically. That means that you can change the template to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {
   body {
p(&apos;Auto indent in action!&apos;)
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;which is much more readable! To understand how it works, let&amp;#8217;s slightly change the template, by moving the &lt;code&gt;body&lt;/code&gt; block to the same line as &lt;code&gt;html&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;html {   body {
p(&apos;Auto indent in action!&apos;)
   }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;in that case, the output is modified accordingly:
-&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint html language-html&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;
        &amp;lt;p&amp;gt;Auto indent in action!&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that new lines are really added where you have them in source code!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_optional_type_checking_of_model&quot;&gt;optional type checking of model&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Imagine the following model:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class User {
   Long id
   String name
}

def model = [user: new User(id: 123, name: &apos;Cedric&apos;)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and the following code to create a template:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def template = engine.createTemplate &apos;&apos;&apos;
p &quot;User id: $user.id Name: $user.name Age: $user.age&quot;
&apos;&apos;&apos;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The template is compiled fine, but if you try to render it, it will fail:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;template.make(model).writeTo(new PrintWriter(System.out)) 	&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;fails with groovy.lang.MissingPropertyException: No such property: age for class: User&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To avoid failing at render time, you can use a type checked mode:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def template = engine.createTypeCheckedModelTemplate &apos;&apos;&apos;	&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
p &quot;User id: $user.id Name: $user.name Age: $user.age&quot;
&apos;&apos;&apos;, [user: &apos;User&apos;]						&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;use &lt;em&gt;createTypeCheckedModelTemplate&lt;/em&gt; instead of &lt;em&gt;createTemplate&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;provide model type information&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And this time, compilation of the template will fail directly:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - No such property: age for class: User&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that it won&amp;#8217;t wait for an actual template to be rendered for failing, which is a feature some people like (yes, I&amp;#8217;m looking at you, Play! Framework ;)). Now that we&amp;#8217;ve showed a quick list of those features (there are more, like helper methods in model, &amp;#8230;), what about performance? Is it worth it? I thought Groovy, and builders, were slow?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_statically_compiled_templates&quot;&gt;Statically compiled templates&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I had already played with &lt;a href=&quot;/blog/2013/02/13/static_builders_inception.html&quot;&gt;static builders&lt;/a&gt; in the past, and we also have this very nice feature of static type checking extensions in Groovy 2.1. In Groovy 2.2, type checking extensions were extended to static compilation&amp;#8230; So my first idea was to get rid of the &lt;code&gt;StreamingMarkupBuilder&lt;/code&gt;, which is good but not really suited for optimizations. And before I explain the implementation details, here is the result of a more complete benchmark, using my latest implementation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;@Grab(group=&apos;org.gperfutils&apos;, module=&apos;gbench&apos;, version=&apos;0.4.2-groovy-2.1&apos;)
@Grab(&apos;org.freemarker:freemarker:2.3.9&apos;)
import groovy.text.markup.MarkupTemplateEngine
import freemarker.template.*

MarkupTemplateEngine engine = new MarkupTemplateEngine()
def mkpTemplate1 = engine.createTemplate &apos;&apos;&apos;
html {
    body(&apos;It works!&apos;)
}
&apos;&apos;&apos;
def mkpTemplate2 = engine.createTemplate &apos;&apos;&apos;
html {
    body(text)
}
&apos;&apos;&apos;

def mkpTemplate3 = engine.createTemplate &apos;&apos;&apos;
html {
    body(text.toUpperCase())
}
&apos;&apos;&apos;

def mkpTemplate3_typed = engine.createTemplate &apos;&apos;&apos;
html {
    body(((String)text).toUpperCase())
}
&apos;&apos;&apos;

def mkpTemplate4 = engine.createTemplate &apos;&apos;&apos;
html {
    body {
        ul {
            persons.each {
                li(&quot;$text $it&quot;)
            }
        }
    }
}
&apos;&apos;&apos;

def mkpTemplate4_typed = engine.createTemplate &apos;&apos;&apos;
List&amp;lt;String&amp;gt; pList = (List&amp;lt;String&amp;gt;) persons
String txt = text
html {
    body {
        ul {
            for (String p: pList) {
                li(&quot;$txt $p&quot;)
            }
        }
    }
}
&apos;&apos;&apos;

def model = [text:&apos;Hello&apos;, persons:[&apos;Cedric&apos;,&apos;Guillaume&apos;,&apos;Jochen&apos;,&apos;Pascal&apos;,&apos;Paul&apos;]]

def cfg = new Configuration()
def ftlTemplate1 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;It works!&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def ftlTemplate2 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;${text}&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def ftlTemplate3 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;${text?upper_case}&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);
def ftlTemplate4 = new Template(&quot;name&quot;, new StringReader(&apos;&apos;&apos;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;#list persons as person&amp;gt;&amp;lt;li&amp;gt;${text} ${person}&amp;lt;/#list&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&apos;&apos;&apos;), cfg);

def r = benchmark {
    &apos;MarkupTemplateEngine (simple, no binding)&apos; { mkpTemplate1.make([:]).writeTo(new StringWriter()) }
    &apos;Freemarker (simple, no binding)&apos; { ftlTemplate1.process([:], new StringWriter()) }
    &apos;MarkupTemplateEngine (simple binding)&apos; { mkpTemplate2.make(model).writeTo(new StringWriter()) }
    &apos;Freemarker (simple binding)&apos; { ftlTemplate2.process(model, new StringWriter()) }
    &apos;MarkupTemplateEngine (simple toUpper)&apos; { mkpTemplate3.make(model).writeTo(new StringWriter()) }
    &apos;Freemarker (simple toUpper)&apos; { ftlTemplate3.process(model, new StringWriter()) }
    &apos;MarkupTemplateEngine (typed toUpper)&apos; { mkpTemplate3_typed.make(model).writeTo(new StringWriter()) }
    &apos;MarkupTemplateEngine loop&apos; { mkpTemplate4.make(model).writeTo(new StringWriter()) }
    &apos;MarkupTemplateEngine typed for loop&apos; { mkpTemplate4_typed.make(model).writeTo(new StringWriter()) }
    &apos;FreeMarker loop&apos; {  ftlTemplate4.process(model, new StringWriter()) }
}

r.prettyPrint()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;                                           user  system   cpu  real

MarkupTemplateEngine (simple, no binding)   609       0   609   615
Freemarker (simple, no binding)             400       0   400   410
MarkupTemplateEngine (simple binding)       628       3   631   631
Freemarker (simple binding)                 864       0   864   877
MarkupTemplateEngine (simple toUpper)       681       0   681   690
Freemarker (simple toUpper)                 972       0   972   986
MarkupTemplateEngine (typed toUpper)        696       3   699   706
MarkupTemplateEngine loop                  2927      12  2939  2949
MarkupTemplateEngine typed for loop        2579       0  2579  2615
FreeMarker loop                            2862       0  2862  2894&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, there is a &lt;strong&gt;huge&lt;/strong&gt; difference. For non trivial templates, the markup template engine is even faster than Freemarker! To acheive such performance, all templates are compiled into bytecode, but also make use of static compilation, type checking extensions, AST transformations, &amp;#8230;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the next part, I will describe the techniques I used to implement this engine. Meanwhile, let me know what you think of it. If you feel brave, you can test it by checking out the sources on my fork:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git clone -b markup-template-engine https://github.com/melix/groovy-core.git
./gradlew console	&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;will compile Groovy and open a Groovy console where you can test the template engine&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Update: In &lt;a href=&quot;/blog/2014/02/markuptemplateengine_part2.html&quot;&gt;the next part&lt;/a&gt;, we discuss the technical details.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Authoring your blog on GitHub with JBake and Gradle</title>
      <link>http://melix.github.io/blog//2014/02/hosting-jbake-github.html</link>
      <pubDate>lun., 3 févr. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2014/02/hosting-jbake-github.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A few weeks ago, I started this new blog and decided to host it on GitHub. I already explained
&lt;a href=&quot;/blog/2013/11/21/a_new_home.html&quot;&gt;how I migrated contents from JRoller&lt;/a&gt;, but I didn&amp;#8217;t really
the tool behind publishing. In this post, I will show you how easy it is, now that I have
improved my toolchain with &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_jbake&quot;&gt;JBake&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; is a static site generator. When I chose this tool for my blog,
what attracted me is actually that it runs on the JVM, so I already had the idea of automating
stuff with &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since then, I have submitted several pull requests to the project, and we&amp;#8217;re actually thinking
of using it to build the next Groovy website. &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; has good chances to
become the &quot;Jekyll of the JVM&quot; and already supports multiple markup languages (markdown, asciidoc)
as well as multiple template engines (&lt;a href=&quot;http://freemarker.org/&quot;&gt;FreeMarker&lt;/a&gt; in 2.2.1, &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy&lt;/a&gt;
and &lt;a href=&quot;http://www.thymeleaf.org/&quot;&gt;Thymeleaf&lt;/a&gt; in 2.3.0).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The idea behind &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; is very simple: contents is written using a markup language and &quot;baked&quot;
with template engines into actual HTML. Everything is generated statically and you can upload the generated site
wherever you want.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;On the other side, GitHub offers a nice tool to publish pages: &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;, so we can
have both the sources of our blog and the output of bakery in the same repository. So the initial process looked
like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;create a new page in &lt;code&gt;content&lt;/code&gt; directory&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run &lt;code&gt;jbake&lt;/code&gt; command, check the result, eventually make changes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git add page.adoc&lt;/code&gt; to add the new page to the sources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git commit -a&lt;/code&gt; to commit the page to the &lt;code&gt;master&lt;/code&gt; branch, corresponding to the sources of the blog&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git checkout gh-pages&lt;/code&gt; to switch to the GitHub pages branch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cp -R output/* .&lt;/code&gt; to copy the contents of the output directory at the root of the GitHub pages&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git add page.html&lt;/code&gt; to add the new page to the GitHub pages branch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git commit -a&lt;/code&gt; to commit the contents to GitHub pages&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt; to push the sources to GitHub&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push origin gh-pages&lt;/code&gt; to push the generated pages to GitHub pages&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I published my first blog posts like this, and it&amp;#8217;s not that complicated, but it involves a lot of manual steps, so I
came up with a Gradle plugin to make this much easier, that is, focusing on contents, period!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_gradle_to_the_rescue&quot;&gt;Gradle to the rescue!&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_prerequisites&quot;&gt;Prerequisites&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;re going to setup a project that will allow you to publish to GitHub pages in one step, using &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt;. For that,
we will need:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;an empty &lt;em&gt;blog&lt;/em&gt; repository that you created on GitHub&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; to setup the initial JBake project structure&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt; 1.10 (previous versions should work too)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/jbake-org/jbake-gradle-plugin&quot;&gt;JBake plugin for Gradle&lt;/a&gt;, will be downloaded automatically&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/ajoberstar/gradle-git&quot;&gt;Git plugin for Gradle&lt;/a&gt;, will be downloaded automatically&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_building_jbake&quot;&gt;Building JBake&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This step will become optional when JBake 2.3.0 will be out (or a snapshot of &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; will be published). Meanwhile, you
need to install a local version of &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; into your local Maven repository. Don&amp;#8217;t worry, this will be easy, you will
only need Maven (hey, too bad &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; doesn&amp;#8217;t use Gradle ;)):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git clone https://github.com/jbake-org/jbake.git
cd jbake
mvn install&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s all!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_setting_up_a_project&quot;&gt;Setting up a project&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First step consists in creating the initial project layout:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;git init                                                            &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
git remote add origin &amp;lt;your github remote url&amp;gt;                      &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
mkdir -p src/jbake                                                  &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
gradle init                                                         &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
git add build.gradle gradle gradlew gradlew.bat settings.gradle src &lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;(5)&lt;/b&gt;
cd src/jbake
jbake -i                                                            &lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;(6)&lt;/b&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;initializes the git repository&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;add your remote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we will put JBake sources into that directory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;installs the Gradle wrapper into the repository&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;5&quot;&gt;&lt;/i&gt;&lt;b&gt;5&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;adds Gradle wrapper and initial structure into Git&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;6&quot;&gt;&lt;/i&gt;&lt;b&gt;6&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;initializes the default JBake directory layout&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_using_gradle_to_render_pages&quot;&gt;Using Gradle to render pages&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this point, your &lt;code&gt;src/jbake&lt;/code&gt; directory contains the classic &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; folder contents:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;src
 |-- jbake
       |-- assets    : static assets (images, css, ...)
       |-- content   : blog posts, ...
       |-- templates : HTML templates (by default, uses FreeMarker)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Replace the contents of &lt;code&gt;build.gradle&lt;/code&gt; with the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;build.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;
buildscript {
  repositories {
      mavenLocal() // needed to use the local JBake 2.3.0 build
      jcenter()
  }

  dependencies {
    classpath &apos;me.champeau.gradle:jbake-gradle-plugin:0.1-SNAPSHOT&apos; &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    classpath &apos;org.asciidoctor:asciidoctor-java-integration:0.1.4&apos;  &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;
    classpath &apos;org.freemarker:freemarker:2.3.19&apos;                    &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  }
}

apply plugin: &apos;jbake&apos;                                               &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;import the JBake plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;if you write pages using the Asciidoctor format, this is necessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;if you use the Freemarker template engine, this is necessary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;then apply the plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By default, the plugin will look for JBake sources in &lt;code&gt;src/jbake&lt;/code&gt; and generate the site into &lt;code&gt;build/jbake&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_generating_the_output&quot;&gt;Generating the output&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that this is applied, you can generate the site by running the following command:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;./gradlew -i jbake&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;after the rendering step, you should now have a new directory:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;build
  |-- jbake&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;into which you will find the generated HTML contents. At this point, you could choose to upload those files
to an FTP server, for example, but since we want to host our pages on GitHub, we need to add some configuration
to our build.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_publishing_to_github_pages&quot;&gt;Publishing to GitHub Pages&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Create a new file named &lt;code&gt;publish.gradle&lt;/code&gt; with the following contents:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;publish.gradle&lt;/div&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;buildscript {
  repositories {
      jcenter()
  }

  dependencies {
    classpath &apos;org.ajoberstar:gradle-git:0.6.3&apos;     &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
  }
}

apply plugin: &apos;github-pages&apos;                        &lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;(2)&lt;/b&gt;

githubPages {
  repoUri = &apos;git@github.com:youtname/blog.git&apos;      &lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;(3)&lt;/b&gt;
  pages {
     from(file(&apos;build/jbake&apos;)) {
     	into &apos;.&apos;                                    &lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;(4)&lt;/b&gt;
     }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;use the gradle-git plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;2&quot;&gt;&lt;/i&gt;&lt;b&gt;2&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;apply the plugin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;3&quot;&gt;&lt;/i&gt;&lt;b&gt;3&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;configure your GitHub repository URL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;4&quot;&gt;&lt;/i&gt;&lt;b&gt;4&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;tells the plugin to upload the contents of the &lt;code&gt;build/jbake&lt;/code&gt; directory&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then modify the main &lt;code&gt;build.gradle&lt;/code&gt; file by adding the following task:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;task publish(type: GradleBuild) {           &lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;(1)&lt;/b&gt;
    buildFile = &apos;publish.gradle&apos;
    tasks = [&apos;publishGhPages&apos;]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;&lt;i class=&quot;conum&quot; data-value=&quot;1&quot;&gt;&lt;/i&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;we&amp;#8217;re using a separate, sub-build to avoid a classpath issue with JNA&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now if you do:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;./gradlew publish&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Gradle will pick the contents of the &lt;code&gt;output/jbake&lt;/code&gt; directory, add it to the &lt;code&gt;gh-pages&lt;/code&gt; branch and push it to GitHub,
all in one step! A few seconds later, you should see the result on github.io!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One last thing: this configuration does &lt;strong&gt;not&lt;/strong&gt; add the sources to your git repository. It only deals with the output,
so you still need to add the source files, commit them and push them to GitHub. This is of course optional if you
don&amp;#8217;t want to publish the sources&amp;#8230; If you decide to make them public, then you can also use the git plugin to do it
automatically!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this post, we&amp;#8217;ve shown you how you can leverage &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; and &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt; to publish a blog on GitHub. The setup is really
easy, so I hope more people will follow that way and contribute to Open Source too!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, this post has been published using the procedure described on this page, so I used &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; and &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt; to blog
about how to publish a blog on &lt;a href=&quot;https://github.com/melix/blog&quot;&gt;GitHub&lt;/a&gt; using &lt;a href=&quot;http://www.jbake.org&quot;&gt;JBake&lt;/a&gt; and &lt;a href=&quot;http://www.gradle.org&quot;&gt;Gradle&lt;/a&gt;! Like my friend Andres Almiray
would say, that&amp;#8217;s a &lt;a href=&quot;https://twitter.com/aalmiray/status/429236158321950720&quot;&gt;toolception&lt;/a&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>JLangDetect 0.4 released and moved to GitHub</title>
      <link>http://melix.github.io/blog//2014/01/jlangdetect-github.html</link>
      <pubDate>mer., 22 janv. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2014/01/jlangdetect-github.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_a_new_era&quot;&gt;A new era&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Back in 2011, I initiated a project called &lt;code&gt;JLangDetect&lt;/code&gt;, a language detection library for the JVM. At that time, I was working for
a company that made NLP tools and I started this as a pet project on my free time. I made it available as open source software and
people started to use it, so I was pretty happy at that time to see a project I initiated being actually used in production!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While I don&amp;#8217;t have the need for such a library now that I work on the Groovy language, some people are still using it. At the first
place, a friend of mine, Freddy Rabiller, took time to upgrade it. A new version has been released (0.4) and the project is now
available on &lt;a href=&quot;https://github.com/melix/jlangdetect&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A big thank to Freddy, who will probably take the lead of development on this project now!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Closure parameter type inference for Groovy</title>
      <link>http://melix.github.io/blog//2014/01/closure_param_inference.html</link>
      <pubDate>mar., 7 janv. 2014 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2014/01/closure_param_inference.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s start 2014 with a new blog post about a long standing request since we introduced static type checking in Groovy 2: closure parameter type inference.
Before we start, let me wish you a happy new year and a lot of open source contributions!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_type_checking_closure_parameter_types&quot;&gt;Type checking closure parameter types&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To illustrate the problem, let&amp;#8217;s start with this very simple, standard, Groovy code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;void test() {
    assert [&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;].collect { it.toUpperCase() } == [&apos;FOO&apos;,&apos;BAR&apos;,&apos;BAZ&apos;]
}
test()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This code compiles and runs perfectly fine. Now if you want the &lt;em&gt;test&lt;/em&gt; method to be type safe, you can annotate it with &lt;em&gt;@TypeChecked&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert [&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;].collect { it.toUpperCase() } == [&apos;FOO&apos;,&apos;BAR&apos;,&apos;BAZ&apos;]
}
test()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you compile this, you will notice that the compiler fails with an error:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 5, column: 42&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Fixing this requires an explicit closure parameter type:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;import groovy.transform.TypeChecked

@TypeChecked
void test() {
    assert [&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;].collect { String it -&amp;gt; it.toUpperCase() } == [&apos;FOO&apos;,&apos;BAR&apos;,&apos;BAZ&apos;]
}
test()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem comes from the &lt;em&gt;collect&lt;/em&gt; method, which accepts a &lt;code&gt;Closure&lt;/code&gt;. In Groovy, a &lt;code&gt;Closure&lt;/code&gt; is a block of code which may capture variables, but it is also
represented as an object of the class &lt;code&gt;Closure&lt;/code&gt;. This is a different concept from Java 8 lambdas, which have no &lt;em&gt;Lambda&lt;/em&gt; class, for example. A Java 8 lambda can
be considered as purely syntactic sugar, which is interpreted as an interface implementation at compile time, although a &lt;code&gt;Closure&lt;/code&gt; can be manipulated. To illustrate
this, let&amp;#8217;s compare the signatures of &lt;em&gt;collect&lt;/em&gt; (in Groovy) and &lt;code&gt;Map&lt;/code&gt; (in Java 8) which correspond to the same concept:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T,U&amp;gt; List&amp;lt;U&amp;gt; collect(List&amp;lt;T&amp;gt; source, Closure&amp;lt;U&amp;gt; closure) &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;items of the source list are of type T and converted to type U using the closure&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper); &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Function is an interface, the lambda expression will be converted into this target interface&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Java 8 equivalent would therefore be:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;list.stream().map((it)-&amp;gt;it.toUpperCase()).collect(Collectors.toList()); &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;we&amp;#8217;re not using the smarter method reference notation here, to illustrate the concept&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, Java allows the same thing as Groovy but doesn&amp;#8217;t require an explicit type. The reason is that for Java, there&amp;#8217;s no ambiguity:
it makes use of &lt;em&gt;target typing&lt;/em&gt;. Since a lambda is targetting an interface, the type of the parameters can be inferred from the interface type.
In Groovy, we can&amp;#8217;t do this, because &lt;code&gt;Closure&lt;/code&gt; is not an interface. It is a class which can be manipulated. At this point, you may wonder why
we don&amp;#8217;t do the same as in Java, and there are several reasons:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;historical reason first, &lt;code&gt;Closure&lt;/code&gt; was one of the key features of the language, 10 years ago!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a single class, &lt;code&gt;Closure&lt;/code&gt;, is enough for &lt;strong&gt;all&lt;/strong&gt; usages of an open block. We don&amp;#8217;t need Function, Consumer, BiFunction, &amp;#8230; So we can dramatically
reduce the amount of &quot;design interfaces&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;last but not least, &lt;em&gt;Closures&lt;/em&gt; support various delegation strategies. This is something Java (or even Scala) is totally unable to do. &lt;code&gt;Closure&lt;/code&gt; can
be &lt;em&gt;cloned&lt;/em&gt;, &lt;em&gt;curried&lt;/em&gt;, &lt;em&gt;trampolined&lt;/em&gt;, &amp;#8230; and it always returns an instance of another &lt;code&gt;Closure&lt;/code&gt;. This closure can change the delegate, which is the
key for nice builder like DSLs. The delegate is used whenever a method call in a closure doesn&amp;#8217;t have an explicit receiver. For example:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;mail {
   from &apos;austin.powers@groovy.baby&apos;
   to &apos;mini.me@evil.com&apos;
   subject &apos;Attention please!&apos;
   body &apos;...&apos;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this DSL, the &lt;em&gt;from&lt;/em&gt;, &lt;em&gt;to&lt;/em&gt;, &lt;em&gt;subject&lt;/em&gt; and &lt;em&gt;body&lt;/em&gt; method calls are done on the &lt;em&gt;delegate&lt;/em&gt;. Being able to set the &lt;em&gt;delegate&lt;/em&gt; absolutely requires a
&lt;code&gt;Closure&lt;/code&gt; class. The implementation of the mail method may have something like:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class EmailSpecification {
    void from(String sender) { ... }
    void to(String to) { ... }
    void subject(String subject) { ... }
    void body(String body) { ... }
    void mail(Closure mail) {
       def mailSpec = mail.clone()
       mailSpec.delegate = this
       mailSpec()
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem with this approach is that if the closure requires parameters, like in the &lt;em&gt;collect&lt;/em&gt; case, the Java type system, as well as the Groovy type
system (which is the same), isn&amp;#8217;t expressive enough to let you define them:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T,U&amp;gt; List&amp;lt;U&amp;gt; collect(List&amp;lt;T&amp;gt; source, Closure&amp;lt;U&amp;gt; closure) &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We could like to say that Closure returns a U, but also that it consumes a T&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course the first option that was studied was defining lots of &lt;code&gt;Closure&lt;/code&gt; interfaces, corresponding to the various number of arguments (up to some arbitrary limit):&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T,U&amp;gt; List&amp;lt;U&amp;gt; collect(List&amp;lt;T&amp;gt; source, Closure1&amp;lt;T,U&amp;gt; closure) &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Closure1 is a kind of closure which accepts a single argument and returns a value&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;While this works, it has several drawbacks:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;it requires a lot of arbitrary, totally useless in a dynamic context, number of interfaces/classes to define closures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it doesn&amp;#8217;t solve the case of polymorphic closures&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_polymorphic_closures&quot;&gt;Polymorphic closures&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Polywhat? In Groovy, closures can be polymorphic. To illustrate the concept, let&amp;#8217;s take a look at a common method that iterates on map entries:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def map = [key1: &apos;value 1&apos;, key2: &apos;value2&apos;]
map.each { k,v -&amp;gt; println &quot;Key is $k, value is $v&quot; } &lt;b&gt;(1)&lt;/b&gt;
map.each { e -&amp;gt; println &quot;Key is ${e.key], value is ${e.value}&quot; } &lt;b&gt;(2)&lt;/b&gt;
map.each { println &quot;Key is ${it.key], value is ${it.value}&quot; } &lt;b&gt;(3)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;version where the map entry is automatically converted into a key and value arguments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;version where the closure takes a single, &lt;code&gt;Map.Entry&lt;/code&gt; argument&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;version with an implicit argument, it, is a &lt;code&gt;Map.Entry&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In all cases, it is always the &lt;strong&gt;same&lt;/strong&gt; method which is called, that is to say &lt;em&gt;each(Closure)&lt;/em&gt; on a &lt;code&gt;Map&lt;/code&gt;. The signature of this method is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;K,V&amp;gt; each(Map&amp;lt;K,V&amp;gt; self, Closure&amp;lt;?&amp;gt; onEachEntry)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, the return type of the closure doesn&amp;#8217;t help here, and just reading that signature, you have absolutely no way to guess that the closure
will accept either a &lt;code&gt;Map.Entry&lt;/code&gt; or a pair of &lt;code&gt;K,V&lt;/code&gt;. Nor does the compiler. At best, your IDE knows it, and it does because it is hardcoded! This is
exactly why the compiler fails, and also why so many people think it&amp;#8217;s &lt;a href=&quot;https://jira.codehaus.org/browse/GROOVY-5924&quot;&gt;a bug&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Not convinced? Let&amp;#8217;s make the same signature more cryptic:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;Dead,Pool&amp;gt; magneto(Map&amp;lt;Dead,Pool&amp;gt; self, Closure&amp;lt;?&amp;gt; professorX)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now can you guess what &lt;em&gt;professorX&lt;/em&gt; accepts as parameters? ;)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_tweaking_the_type_system&quot;&gt;Tweaking the type system&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We have discussed several options and we took the time to think about it, and after the last Groovy DevCon, which took place just before the
&lt;a href=&quot;http://skillsmatter.com/event-details/home/groovy-grails-exchange-2013&quot;&gt;Groovy and Grails eXchange 2013&lt;/a&gt; in London, I decided to work on an implementation.
For Groovy 2.1, we had introduced &lt;em&gt;@DelegatesTo&lt;/em&gt; for closures, to be able to help the compiler in the case we described above (hinting at the delegate type)
but we were still missing parameter type inference. My guess was that it was possible to do something similar to what &lt;em&gt;@DelegatesTo&lt;/em&gt; does, but for parameter
types.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_annotating_closures&quot;&gt;Annotating closures&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The idea is to annotate closures so that the compiler can fetch the information and infer the argument types from the context. In the case of a simple method
accepting a closure, a simple annotation could do:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;void doSomething(String src, @ClosureParams(String.class) Closure cl) { ... }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;em&gt;@ClosureParams&lt;/em&gt; annotation is here to instruct the compiler that the closure will accept either an &lt;em&gt;implicit&lt;/em&gt; or &lt;em&gt;explicit&lt;/em&gt; parameter of type &lt;em&gt;String&lt;/em&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;doSomething {
   it.toUpperCase()
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the compiler determines that the method which will be called is &lt;em&gt;doSomething&lt;/em&gt; (remember that this is only possible if type checking is activated), then an
additional lookup on the &lt;em&gt;doSomething&lt;/em&gt; signature can be done, and we can retrieve the list of expected parameter types from the closure annotation. Success!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Well, not really:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;we still don&amp;#8217;t support polymorphic closures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generics, GENERICS, aaahhhh, GENERICS!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_introducing_generics&quot;&gt;Introducing&amp;#8230; generics!&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To make things a bit more complicated, we have generics. Don&amp;#8217;t get me wrong. From a user perspective, generics are very good because they make the code more readable
and help reduce the amount of boilerplate (think of vectors/maps before Java 1.5&amp;#8230;). The typical case is the &lt;em&gt;collect&lt;/em&gt; example that we used initially:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T,U&amp;gt; List&amp;lt;U&amp;gt; collect(List&amp;lt;T&amp;gt; source, Closure&amp;lt;U&amp;gt; closure) &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this case, we want to say that the closure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;is monomorphic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;accepts a single parameter of type T&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and the problem is&amp;#8230; how to express this? One might think that you could write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T,U&amp;gt; List&amp;lt;U&amp;gt; collect(List&amp;lt;T&amp;gt; source, @ClosureParams(T) Closure&amp;lt;U&amp;gt; closure) &lt;b&gt;(1)&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;but the truth is that the JVM doesn&amp;#8217;t support placeholders as annotation values, nor does it support parametrized types (like &lt;code&gt;@Foo(List&amp;lt;T&amp;gt;&lt;/code&gt;)). This tells us that the simple strategy doesn&amp;#8217;t work.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_the_solution&quot;&gt;The solution&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The solution we propose is to decouple the declaration of the parameter types from the type itself. In other words, instead of declaring the types in the annotation, we will declare an object
which is used as a hint to compute the types &lt;strong&gt;at compile time&lt;/strong&gt;. In the case of &lt;em&gt;collect&lt;/em&gt;, we end up with this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static &amp;lt;T,E&amp;gt; List&amp;lt;T&amp;gt; collect(List&amp;lt;E&amp;gt; self, @ClosureParams(FirstParam.FirstGenericType.class) Closure&amp;lt;? extends T&amp;gt; transform)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this case, &lt;code&gt;FirstParam.FirstGenericType&lt;/code&gt; doesn&amp;#8217;t represent the type itself. It&amp;#8217;s a hint used by the compiler, which says &quot;the type of the argument is the type of the first generic type of the first parameter&quot;. In this case, the first parameter is &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt;, so the first generic type is &lt;code&gt;E&lt;/code&gt;. This means that if you call the method with a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, now the compiler can infer that &lt;code&gt;E&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_type_hints&quot;&gt;Type hints&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;At this point, you may actually think that this &quot;solution&quot; is a bit complex. However, you have to remember that this kind of work is only necessary if you want to support type inference, so it is really only necessary if you use type checking. This makes this a tool primarily aimed at framework builders. In particular, lots of frameworks are written in Java (including Groovy itself), so the syntax &lt;strong&gt;has&lt;/strong&gt; to be compatible with Java. Second, there&amp;#8217;s no need to define one &lt;code&gt;FirstParam.FirstGenericType&lt;/code&gt; class per method. The same class can be reused for all cases where it makes sense. Remember that it doesn&amp;#8217;t represent the type of the parameters but a way to fetch the type (one level of indirection).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To make things easier for framework writers, the &lt;a href=&quot;https://github.com/groovy/groovy-core/pull/307&quot;&gt;candidate implementation&lt;/a&gt; provides a set of predefined hint classes that should fit most of
the use cases. Let&amp;#8217;s go through the list:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_firstparam&quot;&gt;FirstParam&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;FirstParam&lt;/code&gt; is a hint that says that the expected parameter type corresponds to the first parameter of the method call, like in:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static void downto(BigInteger self, Number to, @ClosureParams(FirstParam.class) Closure closure)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The closure accepts a single parameter of type &lt;code&gt;BigInteger&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_firstparam_firstgenerictype&quot;&gt;FirstParam.FirstGenericType&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This hint is used when the type to use is not the type of the parameter, but the type of the first generic type of the first argument, like in:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static &amp;lt;T,E&amp;gt; Collection&amp;lt;T&amp;gt; collect(Collection&amp;lt;E&amp;gt; self, Collection&amp;lt;T&amp;gt; collector, @ClosureParams(FirstParam.FirstGenericType.class) Closure&amp;lt;? extends T&amp;gt; transform)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that if you have a &lt;code&gt;Collection&lt;/code&gt; defined like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class PersonList extends LinkedList&amp;lt;Person&amp;gt; {}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and that you call collect:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;list.collect { it.name }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;the compiler will be capable of inferring that the type of the first generic type is actually a &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;FirstParam&lt;/code&gt; also supports &lt;code&gt;SecondGenericType&lt;/code&gt; and &lt;code&gt;ThirdGenericType&lt;/code&gt;. You can also find &lt;code&gt;SecondParam&lt;/code&gt; and &lt;code&gt;ThirdParam&lt;/code&gt; which follow the same structure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_mapentryorkeyvalue&quot;&gt;MapEntryOrKeyValue&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This hint is used for cases where the closure may accept a &lt;code&gt;Map.Entry&lt;/code&gt; or a &lt;em&gt;key,value&lt;/em&gt; pair, which is quite common in the Groovy GDK, like &lt;em&gt;each&lt;/em&gt; on maps:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; each(Map&amp;lt;K, V&amp;gt; self, @ClosureParams(MapEntryOrKeyValue.class) Closure closure)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is an example of polymorphic closure. This hint does all the job of telling that the parameter types may be a &lt;code&gt;K,V&lt;/code&gt; pair or a &lt;code&gt;Map.Entry&amp;lt;K,V&amp;gt;&lt;/code&gt;. For that, it expects the map to be the first parameter of the method.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_simpletype&quot;&gt;SimpleType&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Simple type can be used for monomorphic closures, in the cases the closure accepts parameters of a non-parametrized type. In this case, you need to use an option to specify the fully qualified name, like in this example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static void eachByte(InputStream is, @ClosureParams(value=SimpleType.class, options=&quot;byte&quot;) Closure closure)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this example, the closure accepts a single parameter of type &lt;code&gt;byte&lt;/code&gt;. For a non primitive type, you need the fully qualified name:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static Writable filterLine(InputStream self, @ClosureParams(value=SimpleType.class, options=&quot;java.lang.String&quot;) Closure predicate)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If the closure accepts multiple arguments then you need options to be an array:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; T withObjectStreams(Socket socket, @ClosureParams(value=SimpleType.class, options={&quot;java.io.ObjectInputStream&quot;,&quot;java.io.ObjectOutputStream&quot;}) Closure&amp;lt;T&amp;gt; closure)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;_fromstring&quot;&gt;FromString&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The last predefined hint can be used whenever none of the previous hints is suitable. A good example is the &lt;em&gt;sort&lt;/em&gt; method on a collection, which takes a closure which either accepts a single
parameter of type &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is the component type) or two parameters of type &lt;code&gt;T&lt;/code&gt; in which case we have a comparator-style closure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; sort(Collection&amp;lt;T&amp;gt; self, @ClosureParams(value=FromString.class, options={&quot;T&quot;,&quot;T,T&quot;} Closure c)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see, in this example, the &lt;em&gt;options&lt;/em&gt; map defines two possible signatures. The string literal are used at compile time to match those of the method signature. Since it involves much more work for the compiler, it is not recommanded to use &lt;code&gt;FromString&lt;/code&gt; if other options are available, because it would be slower at compile time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_future_work&quot;&gt;Future work&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The candidate implementation is available on &lt;a href=&quot;https://github.com/groovy/groovy-core/pull/307&quot;&gt;GitHub&lt;/a&gt;. It works pretty well, and honestly, I couldn&amp;#8217;t come with any better idea. One very good point of this implementation is that it is Java friendly. You can annotate classes written in pure Java and the Groovy compiler would be able to use the extra information. In the future, we could probably support a nicer syntax for Groovy, but it would require a grammar change, which is not planned until Groovy 3. For example, we could write this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; sort(Collection&amp;lt;T&amp;gt; self, Closure&amp;lt;T or T,T -&amp;gt; ?&amp;gt; c)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Which would totally avoid the &quot;ugliness&quot; of the annotation, while using the same backing tool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last thing, do not hesitate to comment on this blog about the solution we found. Of course, it took some time, and the discussions can be found here:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://groovy.329449.n5.nabble.com/TypeChecked-type-inference-does-not-work-with-closure-td5709972.html#a5709981&quot;&gt;an example of user complaint&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://groovy.329449.n5.nabble.com/Closure-parameter-types-inference-td4978037.html&quot;&gt;Initial, not satisfying, solution, two years ago&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://groovy.329449.n5.nabble.com/Closure-parameter-type-inference-td5717804.html&quot;&gt;discussion about this solution&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Thanks to everybody who participated in the discussion, and, of course, thank you for your comments if any: this is still a &lt;em&gt;candidate&lt;/em&gt; solution, so if you come with any better idea, I&amp;#8217;m open!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
