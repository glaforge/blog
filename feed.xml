<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CÃ©dric Champeau's blog</title>
    <link>http://melix.github.io/blog/</link>
    <atom:link href="http://melix.github.io/blog//feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>ven., 22 nov. 2013 19:44:39 +0100</pubDate>
    <lastBuildDate>ven., 22 nov. 2013 19:44:39 +0100</lastBuildDate>

    <item>
      <title>Performance of coercion vs closures in Groovy 2.2</title>
      <link>http://melix.github.io/blog//2013/11/22/coercion_vs_direct.html</link>
      <pubDate>ven., 22 nov. 2013 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2013/11/22/coercion_vs_direct.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;To inaugurate this new blog, I will discuss the topic of coercion performance in Groovy. Especially, you might now
that Groovy 2.2 &lt;a href=&quot;http://docs.codehaus.org/display/GROOVY/Groovy+2.2+release+notes&quot;&gt;introduced implicit closure coercion&lt;/a&gt;.
If you don&amp;#8217;t know what closure coercion is, or just what &lt;em&gt;coercion&lt;/em&gt; alone is, let&amp;#8217;s start with a reminder.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_casting_vs_coercion&quot;&gt;Casting vs coercion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_casting&quot;&gt;Casting&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In an object oriented language like &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy&lt;/a&gt;, variables are typed. Even if Groovy is a dynamic
language, each variable has a type at runtime. Even if Groovy shares the same typing model as Java, there&amp;#8217;s almost no
need for casting in Groovy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Casting in Java is necessary because it&amp;#8217;s a statically typed language, so if you want to call a method defined on the
&lt;code&gt;Person&lt;/code&gt; class on an object which is declared as type &lt;code&gt;Object&lt;/code&gt;, you &lt;strong&gt;have&lt;/strong&gt; to do a cast:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint java language-java&quot;&gt;&lt;code&gt;String pretty(Object o) {
    if (o instanceof Person) {
	return ((Person)o).getName(); &lt;b&gt;(1)&lt;/b&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;(Person) is an explicit cast&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;in Groovy, casting is not necessary because we rely on runtime types and dynamic invocation. This means that this code is
equivalent to this in Groovy:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;String pretty(o) {
    o.name &lt;b&gt;(1)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;casting isn&amp;#8217;t required&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Casting is only possible within the type hierarchy. That is, you can cast any object to any subtype (or interface) and it&amp;#8217;s
you&amp;#8217;re responsability to make sure (for example using &lt;code&gt;instanceof&lt;/code&gt;) that the runtime type will be correct. If you don&amp;#8217;t, you
may have the famous &lt;code&gt;ClassCastException&lt;/code&gt; error at runtime.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_coercion&quot;&gt;Coercion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For types which are not in the same hierarchy, Groovy provides an alternative mechanism called &lt;em&gt;coercion&lt;/em&gt;. Coercion is very
handy because it basically allows you to convert an object of some type into an object of another, in general incompatible, type.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A good example is converting a &lt;code&gt;File&lt;/code&gt; to a &lt;code&gt;String[]&lt;/code&gt; corresponding to the lines of a text file. In groovy, you can write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def lines = file as String[]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Obviously, if you had written:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def lines = (String[]) file&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then it would have produced a &lt;code&gt;ClassCastException&lt;/code&gt;. Basically, a cast is (almost) a no-op, while coercion involves any kind of
treatment. It is also possible to implement your own coercion rules, by implementing the &lt;code&gt;asType&lt;/code&gt; method:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;class Person {
   String name
   int age
   def asType(Class target) {
      if (List==target) {
         [name,age]
      }
   }
}
def p = new Person(name:&apos;Austin Powers&apos;, age:50)
assert p as List == [&apos;Austin Powers&apos;, 50]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_closure_coercion&quot;&gt;Closure coercion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One of the most widely used features of Groovy is closure coercion. It&amp;#8217;s an easy way to implement interfaces. For example, giving
the following interface:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;interface Predicate {
    boolean apply(Object target)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can implement it using coercion:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;Predicate filter = { it.length() &amp;gt; 3 } as Predicate&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is especially interesting when the interface is used as a method call parameter:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;List filter(List source, Predicate predicate) {
   source.findAll { predicate.apply(it) } &lt;b&gt;(1)&lt;/b&gt;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;note that this example doesn&amp;#8217;t really make sense since it&amp;#8217;s the role of findAll to apply a closure as predicate!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So you can call the method without having to create an anonymous abstract class:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def items = filter([&apos;foo&apos;,&apos;bar&apos;, &apos;foobar&apos;], {
    it.length()&amp;gt;3
} as Predicate)
assert items == [&apos;foobar&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_implicit_closure_coercion_in_groovy_2_2&quot;&gt;Implicit closure coercion in Groovy 2.2&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With the release of Groovy 2.2, closure coercion can be implicit, in case the target is a SAM (single abstract method) type. That is to say that the target type must have a single abstract method, which is the case for many functional interfaces (like &lt;code&gt;Predicate&lt;/code&gt; here) and abstract classes. So the example can be further simplified:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def items = filter(source) { it.length()&amp;gt;3 } &lt;b&gt;(1)&lt;/b&gt;
assert items == [&apos;foobar&apos;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;colist arabic&quot;&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;note that &lt;code&gt;as Predicate&lt;/code&gt; is not needed anymore!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Can it be easier? Probably not, but maybe you noticed that this is close to what Java 8 will allow with lambdas:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; items = filter(source, String str -&amp;gt; str.length()&amp;gt;3)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now you must be aware of some subtle differences with Java 8. One is that closures are &lt;strong&gt;not&lt;/strong&gt; lambdas but instances of the &lt;code&gt;Closure&lt;/code&gt; class (a subclass of &lt;code&gt;Closure&lt;/code&gt;, to be precise), while lambdas are converted at &lt;strong&gt;compile time&lt;/strong&gt; and can be directly implemented, for example, as methods (simple case) or anonymous inner classes. This difference implies that if you have:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def method(Closure c) { ... }
def method(SAMType arg) { ... }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Then if you pass a closure as argument:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;method { ...do something... }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;then the method which is chosen is the version which accepts a &lt;code&gt;Closure&lt;/code&gt;, not the version accepting a &lt;code&gt;SAMType&lt;/code&gt;. But since &lt;code&gt;Closure&lt;/code&gt; implements &lt;code&gt;Runnable&lt;/code&gt; and &lt;code&gt;Callable&lt;/code&gt;, the same is true for those two interfaces:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;def method(Runnable c) { ... }
def method(SAMType arg) { ... }
method { ...do something... } // will call method(Runnable)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This means that if you want to call the &lt;code&gt;SAMType&lt;/code&gt; version, you still have to use explicit coercion:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;method { ...do something... } as SAMType&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now that we exposed the basics of closure coercion, let&amp;#8217;s come to the topic that gave its name to this blog post: performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_performance_of_coercion_vs_closure&quot;&gt;Performance of coercion vs closure&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_gbench&quot;&gt;GBench&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We will discuss here the impact of using closure coercion and compare the cost of implicit/explicit closure coercion as compared with calling a method which directly accepts a closure. For that, let&amp;#8217;s start with the tool we&amp;#8217;re going to use: &lt;a href=&quot;https://code.google.com/p/gbench/&quot;&gt;GBench&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://code.google.com/p/gbench/&quot;&gt;GBench&lt;/a&gt; is a project I really like and that I use a lot. It&amp;#8217;s meant for micro-benchmarking. We know that micro-benchmarks are bad, but in some cases, they are useful. &lt;a href=&quot;https://code.google.com/p/gbench/&quot;&gt;GBench&lt;/a&gt; makes them a little better by providing a framework that does all the boring stuff that you have to do when micro-benchmarking:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setting up timers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;warm up&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;repeat the execution of the same code N times&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generation of a report&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All this using a nice DSL. If you want to write benchmarks, time execution of some process in your Groovy program, make sure to use it, it&amp;#8217;s just the perfect tool.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_measurements&quot;&gt;Measurements&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now let&amp;#8217;s proceed with the measurements. We want to compute the cost of:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;directly accepting a closure as an argument&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coercing the closure to a SAM type then calling&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For that, we&amp;#8217;re just defining a very simple SAM type and two helper methods:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;interface SAMType {
    void apply()
}

@groovy.transform.CompileStatic
void direct(Closure c) { c.call() }

@groovy.transform.CompileStatic
void coercion(SAMType s) { s.apply() }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The two methods that will be called are compiled statically so that we made direct method calls inside the method body. This allows us to measure precisely the cost of calling the method, rather than the cost of dynamic dispatch. The measurements are made using this code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;Closure cachedClosure = { &apos;do something&apos; }
SAMType cachedSAMType = { &apos;do something&apos; }

@Grab(group=&apos;org.gperfutils&apos;, module=&apos;gbench&apos;, version=&apos;0.4.2-groovy-2.1&apos;)
def r = benchmark {
      &apos;explicit coercion&apos; {
          coercion { &apos;do something&apos; } as SAMType
      }
      &apos;implicit coercion&apos; {
          coercion { &apos;do something&apos; }
      }
      &apos;direct closure&apos; {
          direct { &apos;do something&apos; }
      }
      &apos;cached SAM type&apos; {
          coercion cachedSAMType
      }
      &apos;cached closure&apos; {
          direct cachedClosure
      }
  }
  r.prettyPrint()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can see that we are testing 5 cases here:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;explicit coercion&lt;/code&gt; calls the method accepting a &lt;code&gt;SAMType&lt;/code&gt; with explicit coercion of a closure into a &lt;code&gt;SAMType&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;implicit coercion&lt;/code&gt; does the same, without &lt;code&gt;as SAMType&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;direct closure&lt;/code&gt; calls the method accepting a &lt;code&gt;Closure&lt;/code&gt;. This means that this version will &lt;strong&gt;not&lt;/strong&gt; involve any conversion.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cached SAM type&lt;/code&gt; calls the &lt;code&gt;SAMType&lt;/code&gt; version of the method with a coerced closure which is defined &lt;strong&gt;outside&lt;/strong&gt; of the scope of the benchmark method&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cached closure&lt;/code&gt; calls the &lt;code&gt;Closure&lt;/code&gt; version of the method with a closure which is defined &lt;strong&gt;outside&lt;/strong&gt; of the scope of the benchmark method&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The last two versions are interesting because as I explained before, &lt;a href=&quot;https://code.google.com/p/gbench/&quot;&gt;GBench&lt;/a&gt; automatically repeats the execution of the code N times. This means that this code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;SAMType cachedSAMType = { &apos;do something&apos; }
// ...
&apos;cached SAM type&apos; {
    coercion cachedSAMType
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;is more or less equivalent to:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;SAMType cachedSAMType = { &apos;do something&apos; }
// ...
10000.times {
    coercion cachedSAMType
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So here is the result of the execution of this benchmark:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;Environment
===========
* Groovy: 2.2.0-rc-3
* JVM: Java HotSpot(TM) 64-Bit Server VM (23.5-b02, Oracle Corporation)
    * JRE: 1.7.0_09
    * Total Memory: 679.4375 MB
    * Maximum Memory: 1765.375 MB
* OS: Linux (3.8.0-22-generic, amd64)

Options
=======
* Warm Up: Auto (- 60 sec)
* CPU Time Measurement: On

                   user  system   cpu  real

explicit coercion  1258       0  1258  1259
implicit coercion  1102      12  1114  1115
direct closure      318       5   323   324
cached SAM type     263       0   263   265
cached closure      259       0   259   261&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What you can see from those results is that:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;using implicit closure coercion is slightly faster than explicit closure coercion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;having a method which accepts directly a closure can significantly improve performance (almost 4x faster dispatch!)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;using a cached closure or a cached SAM type is fast in any case&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that using cached closures is not something that is specific to Groovy: it would be true for any Java code too, if you consider a coerced closure as an anonymous inner class. Each time the method is called, you create a &lt;strong&gt;new instance&lt;/strong&gt; of the closure (or, in Java, the anonymous inner class). So moving the definition of the closure (or anonymous inner class) outside the loop and you will reuse the &lt;strong&gt;same instance&lt;/strong&gt;, dramatically improving performance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We must explain what performance we&amp;#8217;re talking about here: the closure does nothing special here, just returning a dummy string. So the cost of the treatment is almost null. What if the code actually does something? Would the differences be so important? To check that, we will modify the code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;interface SAMType {
    void apply()
}

@groovy.transform.CompileStatic
void coercion(SAMType s) { s.apply() }

@groovy.transform.CompileStatic
void direct(Closure c) { c.call() }

void doSomething() {
   Thread.sleep(100)
}

Closure cachedClosure = { doSomething() }
SAMType cachedSAMType = { doSomething() }

@Grab(group=&apos;org.gperfutils&apos;, module=&apos;gbench&apos;, version=&apos;0.4.2-groovy-2.1&apos;)
def r = benchmark {
      &apos;explicit coercion&apos; {
          coercion { doSomething() } as SAMType
      }
      &apos;implicit coercion&apos; {
          coercion { doSomething() }
      }
      &apos;direct closure&apos; {
          direct { doSomething() }
      }
      &apos;cached SAM type&apos; {
          coercion cachedSAMType
      }
      &apos;cached closure&apos; {
          direct cachedClosure
      }
  }
  r.prettyPrint()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this version, we simulate a long running process with &lt;code&gt;Thread.sleep(100)&lt;/code&gt;. The results are shown below:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;                     user  system     cpu       real

explicit coercion  248621       0  248621  100329258
implicit coercion  208407       0  208407  100273428
direct closure          0  166932  166932  100238245
cached SAM type         0  157406  157406  100232334
cached closure          0  160848  160848  100214197&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that it&amp;#8217;s better to look at the &lt;code&gt;real&lt;/code&gt; column here, since &lt;code&gt;Thread.sleep&lt;/code&gt; doesn&amp;#8217;t consume any CPU. What is interesting here is that now, there&amp;#8217;s almost no difference between each version. This is simply explained: the cost of the treatment exceeds the cost of instantiating a closure and coercing it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;So given those figures, what can we conclude? First of all, one of the interests of implicit closure coercion is that previously (before Groovy 2.2), if you wanted users to avoid explicit coercion, you had to write a method accepting a closure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;// real method
void addListener(Listener listener) { ... }
// convenience method to avoid explicit coercion from user code
void addListener(Closure cl) { addListener(cl as Listener) }&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem is that you double the number of methods here, so implicit closure coercion is a big bonus here. But our figures showed that calling a method accepting a closure is much faster, so you have a dilemn here: should you keep the closure version or not? The second benchmark gives a first answer: you shouldn&amp;#8217;t remove the &lt;code&gt;Closure&lt;/code&gt; version only if you know that the treatment in the closure is &lt;strong&gt;very&lt;/strong&gt; fast. As soon as business code in the closure is a bit complex, it&amp;#8217;s not worth it and you can remove the &lt;code&gt;Closure&lt;/code&gt; version. This means that in the vast majority of cases, you can remove it without problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In fact, there&amp;#8217;s one more case where you&amp;#8217;d want to keep the &lt;code&gt;Closure&lt;/code&gt; version: if you manipulate the closure before calling it, like changing the delegate:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint groovy language-groovy&quot;&gt;&lt;code&gt;void doSomething(SAMType arg) { ... }
void doSomething(Closure cl) {
   def clone = cl.rehydrate(delegate,this,this)
   doSomething(clone as SAMType)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Hope things are clearer for you now!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>A new home!</title>
      <link>http://melix.github.io/blog//2013/11/21/a_new_home.html</link>
      <pubDate>jeu., 21 nov. 2013 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">/2013/11/21/a_new_home.html</guid>
      	<description>
	&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Goodbye JRoller, welcome GitHub! Eventually, I migrated my blog to &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub pages&lt;/a&gt;. It is a now a statically generated website.
What is interesting here is how I migrated contents from my &lt;a href=&quot;http://jroller.com/melix&quot;&gt;old blog&lt;/a&gt;. I used a &lt;a href=&quot;http://groovy.codehaus.org&quot;&gt;Groovy&lt;/a&gt; script which
downloaded the old pages, converted them into &lt;a href=&quot;http://asciidoctor.org&quot;&gt;Asciidoctor&lt;/a&gt; format so that they can be statically processed by &lt;a href=&quot;http://jbake.org&quot;&gt;JBake&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Should you need something similar, I pushed this little toy here: &lt;a href=&quot;https://github.com/melix/jroller-export&quot;&gt;https://github.com/melix/jroller-export&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now the export is quite raw, there are probably minor rendering issues to fix, or broken links, and I still have to integrate:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;twitter/google+ share buttons&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;comments&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But this is another story!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last but not least, this blog is also published on GitHub and all posts are published under &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/2.0/en/&quot;&gt;Creative Commons by-nb-sa&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>deck2pdf: Exporting HTML5 slide decks to PDF</title>
      <link>http://melix.github.io/blog//2013/07/30/deck2pdf_exporting_html5_slide_decks.html</link>
      <pubDate>mar., 30 juil. 2013 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">/2013/07/30/deck2pdf_exporting_html5_slide_decks.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_exporting_your_awesome_html5_presentation_to_pdf&quot;&gt;Exporting your awesome HTML5 presentation to PDF&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For some time now, Iâve started using &lt;a href=&quot;http://imakewebthings.com/deck.js/&quot;&gt;deck.js&lt;/a&gt; to write my talks. One of the reasons I do this is that it saves me &lt;strong&gt;lots&lt;/strong&gt; of time when I have to copy and paste code, because I can rely on javascript code highlighting libraries to do the job. I can focus on contents instead of rendering. If I had a better knowledge of CSS, too, I could certainly write impressive presentations (but unfortunately, no, Iâm not good at CSS).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The problem with HTML5 slideshows is that you are often asked to upload your slides as PDF. For example, &lt;a href=&quot;https://speakerdeck.com/&quot;&gt;SpeakerDeck&lt;/a&gt;, &lt;a href=&quot;http://www.slideshare.net/&quot;&gt;SlideShare&lt;/a&gt; or &lt;a href=&quot;http://www.parleys.com/&quot;&gt;Parleys&lt;/a&gt; all require you to upload slides as PDF. None of them supports HTML5 (which is understandable because there are many frameworks available). While I did find some libraries that did the job (often in Perl or Ruby), I never managed to find one that actually worked properly.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_deck2pdf&quot;&gt;Deck2pdf&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Thatâs where it all started. I knew that JavaFX2 provided a WebView, which allowed rendering HTML pages with WebKit. What if I could use it to render my slide deck and export it to PDF? &lt;a href=&quot;https://github.com/melix/deck2pdf&quot;&gt;deck2pdf was born!&lt;/a&gt;. I started with something that was able to export my &lt;a href=&quot;http://imakewebthings.com/deck.js/&quot;&gt;deck.js&lt;/a&gt; presentations, but I figured out very quickly that it could support other HTML5 presentation libraries quite easily. As of today, &lt;a href=&quot;https://github.com/melix/deck2pdf&quot;&gt;deck2pdf&lt;/a&gt; supports:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://imakewebthings.com/deck.js/&quot;&gt;deck.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;reveal.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://bartaz.github.io/impress.js&quot;&gt;impress.js&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and &lt;a href=&quot;https://github.com/paulrouget/dzslides&quot;&gt;DZSlides&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But more importantly, if your favorite HTML5 slideware is not supported, adding custom profiles is supported and fairly easy! Adding support for another library is as simple as adding a descriptor file with the javascript commands inside. For example, hereâs how the &lt;a href=&quot;http://imakewebthings.com/deck.js/&quot;&gt;deck.js&lt;/a&gt; profile is written:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;totalSlides=$.deck(&apos;getSlides&apos;).length
nextSlide=$.deck(&apos;next&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Thatâs all! Support for more complex interactions is also provided using Groovy profiles, like for example in &lt;a href=&quot;http://bartaz.github.io/impress.js&quot;&gt;impress.js&lt;/a&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;setup = {
    js &apos;var api = impress();&apos;
    js &apos;&apos;&apos;var $$ = function ( selector, context ) {
        context = context || document;
        return context.querySelectorAll(selector);
    };&apos;&apos;&apos;
    js &apos;&apos;&apos;var byId = function ( id ) {
        return document.getElementById(id);
    };&apos;&apos;&apos;
}

nextSlide = {
    js(&apos;api.next()&apos;)
}

totalSlides = {
    js (/$$(&quot;.step&quot;, byId(&apos;impress&apos;)).length/)
}

// longer pause because of transitions
pause = 2000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Of course, &lt;a href=&quot;https://github.com/melix/deck2pdf&quot;&gt;deck2pdf&lt;/a&gt; is open source and licensed under &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0.html&quot;&gt;APL2&lt;/a&gt;. Feel free to fork it and contribute new profiles! The home page of the project has documentation explaining how you can create your own. Iâm waiting for your pull requests!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>GR8Conf Europe 2013 is over</title>
      <link>http://melix.github.io/blog//2013/05/27/gr8conf_europe_2013_is_over.html</link>
      <pubDate>lun., 27 mai 2013 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">/2013/05/27/gr8conf_europe_2013_is_over.html</guid>
      	<description>
	&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_gr8conf_europe_2013&quot;&gt;GR8Conf Europe 2013&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Last week I spoke at &lt;a href=&quot;http://gr8conf.eu/index&quot;&gt;GR8Conf Europe&lt;/a&gt; for the second time. As last year, the content of the conference was really amazing and highly technical. While the conference started with a University day on May, 22, we took advantage of the conference to organize a Groovy DevCon the day before. A Groovy DevCon is basically a physical meeting for the Groovy Core developers, where we share ideas and eventually make decisions with regards to the future of Groovy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This year, several well-known Groovy gurus participated in the meeting:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://twitter.com/glaforge&quot;&gt;Guillaume Laforge&lt;/a&gt;, the Groovy project lead&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http://[Jochen &amp;#8220;Blackdrag&amp;#8221; Theodorou], the Groovy technical lead&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://twitter.com/mittie&quot;&gt;Dierk Koenig&lt;/a&gt;, Groovy committer and main author of the famous Groovy in action book&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://twitter.com/aalmiray&quot;&gt;AndrÃ©s Almiray&lt;/a&gt;, the Griffon lead&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://twitter.com/CedricChampeau&quot;&gt;myself&lt;/a&gt;, Groovy Core committer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But we had a special guest, &lt;a href=&quot;http://gr8conf.eu/Speakers/Juergen-Hoeller&quot;&gt;M. Juergen Hoeller of Spring fame&lt;/a&gt; himself!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The meeting was really useful. On my side, I was particularily happy with the discussions regarding Groovy and Java 8, where we eventually took the (long awaited for me) decision to provide some automatic coercion of closures to interfaces. Basically, this means that you would no longer have to write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;    interface Callback {
        void execute()
    }
    void onEvent(Callback c) { c.execute() }

    onEvent({println &apos;hello&apos;} as Callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But instead, you will be able to write directly:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;    interface Callback {
        void execute()
    }
    void onEvent(Callback c) { c.execute() }

    onEvent {println &apos;hello&apos;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This will lead to easier to read and maintain code. We discussed some limitations for the feature, but for a large number of cases, this would work directly. You can expect this feature to appear in Groovy 2.2.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_ast_transformations_unleashed&quot;&gt;AST transformations unleashed&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The University day was the occasion for me to give a workshop about AST transformations. For GR8Conf Europe, I had the chance to do it with &lt;a href=&quot;http://twitter.com/aalmiray&quot;&gt;AndrÃ©s Almiray&lt;/a&gt;, the Griffon lead, but also one of the most talented programmer of the Java community. AndrÃ©s started with a small introduction about AST transformations, then I continued the workshop with &lt;a href=&quot;https://github.com/melix/ast-workshop&quot;&gt;a series of exercises&lt;/a&gt; (that you can take for yourself). Unfortunately, two hours and a half didnât give us enough time to complete all exercises but I was quite happy with the session. I really hope this gave ideas to some people in the room, and that it provided the necessary bits to get started. Note that if you missed it, I will give the same workshop at &lt;a href=&quot;http://gr8conf.us/index&quot;&gt;GR8Conf US in Minneapolis&lt;/a&gt;, so register now!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_type_checking_your_dsls&quot;&gt;Type checking your DSLs&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I gave my second talk on Friday, last day of the conference. It was named &lt;a href=&quot;http://gr8conf.us/Presentations/Type-checking-your-DSLs&quot;&gt;Type checking your DSLs&lt;/a&gt;. While I already gave this talk 3 times before (G&amp;amp;G exchange, Greach and Devoxx France), I always like to change some contents to adapt to the audience and have some novelties inside. Unfortunately, for technical reasons, this talk went really bad for me. I assume people felt it, but I was quite disconcerted. The reason is that most of my talk relies on commenting code, but that I wasnât able to show it properly! Even if the projectors were supposed to support full-HD through HDMI, for some obscure reason, my laptop wasnât able to &amp;#8220;discover&amp;#8221; the HDMI output, and I was stuck to a 1024x768 VGA output. Worse than that, on screen, the borders were cut. This was the first time this ever happened to me, and to be honest, it completely troubled me. I wasnât able to show code properly, so I wasnât able to keep track of what I wanted to say. This was a horrible experience, but I hope people get the idea, as I only managed to give a rough idea of what I wanted to say :-( You know, that feeling when you try to explain something, and that people look at you as if you were an extraterrestrialâ¦&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I will give the same talk at Minneapolis later this year, so I sincerely hope things will go better, especially because I really like this talk, which gives a lot of hints on the power of the language, combining several features available in Groovy 2.1. All the (uncut) slides are available &lt;a href=&quot;https://github.com/melix/gr8confeu2013&quot;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Going to GR8Conf for the second time was like last year an incredible experience. I had the chance to talk to lots of talented and famous developers of the Groovy community, as well as sharing with users, which is worth the trip. This gave me for example the occasion to talk to two GPars brains for the first time (Dierk Koenig and Vaclav Pech). Iâd really like to thank Soren for organizing this, as well as the crew for all the goodness that we can see here. Iâm really looking forward to go to the next edition!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>
    <item>
      <title>Null-safe invocation and primitive types</title>
      <link>http://melix.github.io/blog//2013/04/17/null_safe_invocation_and_primitive.html</link>
      <pubDate>mer., 17 avr. 2013 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">/2013/04/17/null_safe_invocation_and_primitive.html</guid>
      	<description>
	&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_null_safe_method_invocation&quot;&gt;Null-safe method invocation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Yesterday, I worked on &lt;a href=&quot;http://jira.codehaus.org/browse/GROOVY-6101&quot;&gt;a bug&lt;/a&gt; reported on the static compiler of Groovy. It appeared that the underlying problem was related to how null-safe invocations are handled when the expected return type is a primitive. Letâs take an example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;class Person {
   String name
   int age
}

Person getPerson() { null }

Person p = getPerson()

def result = p?.age
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now the question is, what is the value of &lt;em&gt;result&lt;/em&gt;? If you run this in the Groovy console, the result would be &lt;em&gt;null&lt;/em&gt;. This is compatible with the assumption that the null-safe invocation operator (?.) always return null if the receiver of the message is null (here, &lt;em&gt;p&lt;/em&gt; is null, so result is null). The definition is pretty easy, but it gets more complicated if you slightly modify the code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;int result = p?.age
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;By explicitely setting the type to &lt;em&gt;int&lt;/em&gt;, executing this would throw an error, stating that you cannot convert &lt;em&gt;null&lt;/em&gt; to &lt;em&gt;int&lt;/em&gt;. It makes sense knowing that the null-safe invoker is supposed to return null if the receiver is null, but it starts getting strange as if &lt;em&gt;p&lt;/em&gt; is not null, the assignment is perfectly valid since &lt;em&gt;getAge()&lt;/em&gt; is expected to return a primitive typeâ¦ This means that unlike the &amp;#8220;normal&amp;#8221; invoker which is guaranteed to keep the method return type untouched, the null-safe invoker does not honor the method signature.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_dynamic_world&quot;&gt;The dynamic world&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What if the null-safe invoker was aware of the return type? In &amp;#8220;null-safe&amp;#8221;, you must think about what the &amp;#8220;safe&amp;#8221; part stands for. Itâs definitely the receiver, because you want the invocation to be safe (not failing) if the receiver is null. If the &lt;strong&gt;receiver&lt;/strong&gt; is null, then return null. This means that because &lt;em&gt;p&lt;/em&gt; is null, it chooses to return null, independently of the method that was supposed to be called. Here, the method was &lt;em&gt;getAge()&lt;/em&gt;, which is supposed to return a primitive type. As null is not a primitive, I would expect the null-safe invoker to return a &lt;em&gt;default value&lt;/em&gt; compatible with the primitive type. This means that here, I would expect the null-safe invoker to return &lt;em&gt;0&lt;/em&gt;. Now, what is the problem with returning a default value? First of all, weâre in a dynamic world. This means that when &lt;em&gt;p?.age&lt;/em&gt; is executed, the target method hasnât been chosen, because you need to know the runtime type of &lt;em&gt;p&lt;/em&gt; to determine what method will eventually be called. As &lt;em&gt;p&lt;/em&gt; is null, the dynamic runtime doesnât know the type of &lt;em&gt;p&lt;/em&gt;, so has no idea that calling &lt;em&gt;age&lt;/em&gt; would return a primitive type. Conclusion, in a dynamic world, the null-safe invoker must always return null, even if the expected method would return a primitiveâ¦&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_the_static_world&quot;&gt;The static world&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now what if weâre in a pure static world? In that case, the method to be called is chosen at compile time, given the inferred type of &lt;em&gt;p&lt;/em&gt;. It means that unlike the dynamic runtime, the static compiler, at this point, knows that &lt;em&gt;p.age&lt;/em&gt; is &lt;em&gt;p.getAge()&lt;/em&gt; which returns a primitive type. So it is capable of handling the null-safe invocation with what I think is better, semantically speaking: &lt;em&gt;null-safe&lt;/em&gt; invocation only checks the receiver, and returns a value which depends on the return type of the method being invoked. So a static compiler is able to return &lt;em&gt;0&lt;/em&gt; instead of the non-pritive &lt;em&gt;null&lt;/em&gt;. What is funny is that I asked, on Twitter, what people expected from the result of &lt;em&gt;p?.getAge()&lt;/em&gt; if &lt;em&gt;p&lt;/em&gt; is null. Everybody answered &lt;em&gt;null&lt;/em&gt;. So itâs clear that my way of thinking is not mainstream, but Iâm ok with that. I just find it awkward that an operator which is supposed to act on invocation is also capable of altering the return typeâ¦&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;_conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Anyway, even if itâs possible for the static compiler to return a default value, the fix I pushed doesnât do that. It will always return null. The main reason for doing that is not that it was easier to fix (itâs quite the opposite), but that it keeps the semantics of statically compiled Groovy equal to those of dynamic Groovy. As itâs not possible for the runtime to know what the method would return, always returning null is fine, even if some situations (static compilation), you know a bit more what would happen :)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
	</description>
    </item>

  </channel> 
</rss>
